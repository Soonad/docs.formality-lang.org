## Dependent Types

**Obs: Work in progress**

Cover things like:

- Returning a different type based on the function's input

    ```haskell
    iff : {x : Bool, ~A : Type, t : A, f : A} -> A
      (use(x))(~{x}A, t, f)

    make_unit_or_word : {x : Bool} -> iff(x, ~Type, Unit, Word)
      case/Bool x
      | true  => unit
      | false => 42
      : iff(x, ~Type, Unit, Word)
    ```

- Manipulating equalities

    ```haskell
    b_is_true : {a : Bool, b : Bool, b_is_a : Equal(Bool, %b, %a), a_is_true : Equal(Bool, %a, %true)} -> Equal(Bool, %b, %true)
      rewrite(~Bool, ~%a, ~%true, a_is_true, ~{a} Equal(Bool, %b, %a), b_is_a)
    ```

- Specifying precise algorithm (for work outsourcing)

    ```haskell
    // {- "I want a function that receives a bool and returns a different bool" -}
    Specification : Type
      {a : Bool} -> [b : Bool, Not(Equal(Bool, %a, %b))]
      
    // {- "This is a valid implementation of the Specification" -}
    nott : Specification 
      {a} case/Bool a
      | true  => [false , ~true_isnt_false]
      | false => [true  , ~false_isnt_true]
      : [b : Bool, Not(Equal(Bool, %a, %b))]
    ```

- Exploiting impossible cases to improve function's interface

    ```haskell
    // {- If we know that a Maybe isn't none, we can extract its contents -}
    extract : {~A : Type, x : Maybe(A), not_none : Not(Equal(Maybe(A), %x, %none(~A)))} -> A
        case/Maybe x
        + not_none : Not(Equal(Maybe(A), %x, %none(~A)))
        | just => x.value
        | none => 
          absurd(not_none(refl(~&Maybe(A), ~%none(~&A))), ~&A)
        : A
    ```

etc.
