

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>&lt;no title&gt; &mdash; Formality-Core 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Formality-Core
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../language/Installation.html">1. fmc</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Formality-Core</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>&lt;no title&gt;</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/techniques/Datatypes.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p># Datatypes</p>
<p>[a link](licence)
Most traditional functional languages of the Haskell/ML family feature algebraic datatypes or ADTs. Those are essentially the bread-and-butter of functional programming. From Lists to Trees to Monads, every data structure in those languages is an ADT. Formality-Core does not include native ADTs; instead, it provides the building blocks for the user to assemble their own datatypes. This is important when it comes to interaction net compilation because the same data structure could be represented in different ways, with different runtime characteristics, each one having benefits and drawbacks. Being explicit about them allows the programmer to have control over the runtime behavior of their programs.</p>
<p>## Scott-Encoding</p>
<p>The Scott-Encoding represents ADTs as a series of lambdas. It doesn’t involve boxes and behaves almost identically to traditional ADTs. The advantage of Scott-Encoded datatypes is that they have O(1) elimination, i.e., pattern-matching is a constant-time operation. The disadvantage is that, since Formality-Core is terminating, you can’t iterate/recurse over them directly; instead, you need to use Church-Encoded helpers. The best way to explain a λ-encoding is by example and comparison, so, here are bools, pairs, and trees, with their Haskell-equivalents:</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>javascript
// ::::::::::
// :: Bool ::
// :::::::::</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">data</span> <span class="n">Bool</span> <span class="o">=</span> <span class="kc">True</span> <span class="o">|</span> <span class="kc">False</span>
<span class="o">//</span> <span class="n">bool_match</span> <span class="n">x</span> <span class="n">true</span> <span class="n">false</span> <span class="o">=</span> <span class="n">case</span> <span class="n">x</span> <span class="n">of</span> <span class="p">{</span> <span class="kc">True</span> <span class="o">=&gt;</span> <span class="n">true</span><span class="p">;</span> <span class="kc">False</span> <span class="o">=&gt;</span> <span class="n">false</span> <span class="p">}</span>
</pre></div>
</div>
<p>def True       : {true false} true
def False      : {true false} false
def bool_match : {x true false} (x true false)</p>
<p>// ::::::::::
// :: Pair ::
// :::::::::</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">data</span> <span class="n">Pair</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Pair</span> <span class="n">a</span> <span class="n">b</span>
<span class="o">//</span> <span class="n">pair_match</span> <span class="n">x</span> <span class="n">pair</span> <span class="o">=</span> <span class="n">case</span> <span class="n">x</span> <span class="n">of</span> <span class="p">{</span> <span class="n">Pair</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=&gt;</span> <span class="n">pair</span> <span class="n">a</span> <span class="n">b</span> <span class="p">}</span>
</pre></div>
</div>
<p>def Pair       : {a b pair} (pair a b)
def pair_match : {x pair} (x {a b} (pair a b))</p>
<p>// ::::::::::
// :: Tree ::
// :::::::::</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">data</span> <span class="n">Tree</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Node</span> <span class="p">(</span><span class="n">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="o">|</span> <span class="n">Leaf</span> <span class="n">a</span>
<span class="o">//</span> <span class="n">tree_match</span> <span class="n">x</span> <span class="n">node</span> <span class="n">leaf</span> <span class="o">=</span> <span class="n">case</span> <span class="n">x</span> <span class="n">of</span> <span class="p">{</span> <span class="n">Node</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=&gt;</span> <span class="n">node</span> <span class="n">a</span> <span class="n">b</span><span class="p">;</span> <span class="n">Leaf</span> <span class="n">val</span> <span class="o">=&gt;</span> <span class="n">leaf</span> <span class="n">val</span> <span class="p">}</span>
</pre></div>
</div>
<p>def Node       : {a b node leaf} (node a b)
def Leaf       : {val node leaf} (leaf val)
def tree_match : {x node leaf} (x {a b} (node a b) {val} (leaf val))</p>
<p>// ::::::::::::::
// :: Examples ::
// :::::::::::::</p>
<p>def main:</p>
<blockquote>
<div><dl class="docutils">
<dt>let bool_ex =</dt>
<dd>let bool       = True
let true_case  = “Bool is true”
let false_case = “Bool is false”
(bool_match bool true_case false_case)</dd>
<dt>let pair_ex =</dt>
<dd>let pair      = (Pair 4 5)
let pair_case = {a b} [“Pair sum is:”, <a href="#id17"><span class="problematic" id="id18">|a + b|</span></a>]
(pair_match pair pair_case)</dd>
<dt>let tree_ex =</dt>
<dd>let tree      = (Node (Leaf 42) (Leaf 64))
let node_case = {a b} “Tree is a Node”
let leaf_case = {val} “Tree is a Leaf”
(tree_match (Node (Leaf 42) (Leaf 64)) node_case leaf_case)</dd>
</dl>
<p>[bool_ex,
[pair_ex,</p>
<blockquote>
<div>tree_ex]]</div></blockquote>
</div></blockquote>
<p><a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a></p>
<p>Thanks to the Scott-Encoding, any Haskell or Agda program that doesn’t involve duplications or recursion can be translated directly to Formality-Core without changes. For iteration and recursion, we need the Church-Encoding.</p>
<p>## Church-Encoding</p>
<p>The Church-Encoding is like a materialization of a Haskell fold. It involves boxes, and is used for bounded iteration and recursion. Without Church-Encodings, Formality-Core would be a boring language where all its programs could do is move/permutate stuff around and stop in linear time. They’re only required for variable-size (i.e., recursive) datatypes, since, on the fixed-size case, Church and Scott are identical. Once again, they’re better explained through examples:</p>
<p><a href="#id9"><span class="problematic" id="id10">``</span></a><a href="#id11"><span class="problematic" id="id12">`</span></a>javascript
// ::::::::::
// :: List ::
// :::::::::</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">data</span> <span class="n">List</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Cons</span> <span class="n">a</span> <span class="p">(</span><span class="n">List</span> <span class="n">a</span><span class="p">)</span> <span class="o">|</span> <span class="n">Nil</span>
<span class="o">//</span> <span class="n">list_fold</span> <span class="n">x</span> <span class="n">cons</span> <span class="n">nil</span> <span class="o">=</span> <span class="n">case</span> <span class="n">x</span> <span class="n">of</span> <span class="p">{</span> <span class="n">Cons</span> <span class="n">x</span> <span class="n">xs</span> <span class="o">=&gt;</span> <span class="n">cons</span> <span class="n">x</span> <span class="p">(</span><span class="n">list_fold</span> <span class="n">xs</span> <span class="n">succ</span> <span class="n">zero</span><span class="p">);</span> <span class="n">Nil</span> <span class="o">=&gt;</span> <span class="n">nil</span> <span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt>def Nil: {cons nil}</dt>
<dd>dup cons = cons
dup nil  = nil
# nil</dd>
<dt>def Cons: {x xs cons nil}</dt>
<dd>dup cons = cons
dup nil  = nil
dup x    = x
dup xs   = (xs #cons #nil)
# (cons x xs)</dd>
<dt>def fold_list: {x cons nil}</dt>
<dd>(x cons nil)</dd>
</dl>
<p>// ::::::::::
// :: Tree ::
// :::::::::</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">data</span> <span class="n">Tree</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Node</span> <span class="p">(</span><span class="n">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="o">|</span> <span class="n">Leaf</span> <span class="n">a</span>
<span class="o">//</span> <span class="n">tree_fold</span> <span class="n">x</span> <span class="n">node</span> <span class="n">leaf</span> <span class="o">=</span> <span class="n">case</span> <span class="n">x</span> <span class="n">of</span> <span class="p">{</span> <span class="n">Node</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=&gt;</span> <span class="n">node</span> <span class="p">(</span><span class="n">tree_fold</span> <span class="n">a</span> <span class="n">node</span> <span class="n">leaf</span><span class="p">)</span> <span class="p">(</span><span class="n">tree_fold</span> <span class="n">b</span> <span class="n">node</span> <span class="n">leaf</span><span class="p">);</span> <span class="n">Leaf</span> <span class="n">val</span> <span class="o">=&gt;</span> <span class="n">leaf</span> <span class="n">val</span> <span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt>def Node: {a b node leaf}</dt>
<dd>dup node = node
dup leaf = leaf
dup a    = (a #node #leaf)
dup b    = (b #node #leaf)
# (node a b)</dd>
<dt>def Leaf: {val node leaf}</dt>
<dd>dup node = node
dup leaf = leaf
dup val  = val
# (leaf val)</dd>
<dt>def fold_tree: {x node leaf}</dt>
<dd>(x node leaf)</dd>
</dl>
<p>// ::::::::::::::
// :: Examples ::
// :::::::::::::</p>
<p>def main:</p>
<blockquote>
<div><dl class="docutils">
<dt>let list_ex =</dt>
<dd>let list      = (Cons #1 (Cons #2 (Cons #3 (Cons #4 Nil))))
let fold_cons = # {x xs} <a href="#id19"><span class="problematic" id="id20">|x + xs|</span></a>
let fold_nil  = # 0
(fold_list list fold_cons fold_nil)</dd>
<dt>let tree_ex =</dt>
<dd>let tree      = (Node (Node (Leaf #1) (Leaf #2)) (Node (Leaf #3) (Leaf #4)))
let fold_node = # {a b} <a href="#id21"><span class="problematic" id="id22">|a + b|</span></a>
let fold_leaf = # {val} val
(fold_tree tree fold_node fold_leaf)</dd>
</dl>
<p>[list_ex, tree_ex]</p>
</div></blockquote>
<p><a href="#id13"><span class="problematic" id="id14">``</span></a><a href="#id15"><span class="problematic" id="id16">`</span></a></p>
<p>Notice how, unlike on the Scott-Encoded versions, here we are able to fold over the structures, summing all their contained values. Moreover, due to the use of boxes, elements contained by a Church-Encoded structure must always be one layer above than them, which, by consequence, means that results of folds are one layer above too.</p>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Sunshine Cybernetics

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>