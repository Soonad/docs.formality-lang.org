

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>12. Datatypes &mdash; Formality-Core 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="13. Formality Net" href="../runtime/Formality-Net.html" />
    <link rel="prev" title="11. Undefined behavior" href="../language/Undefined-Behavior.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #444053" >
          

          
            <a href="../index.html" class="icon icon-home"> Formality-Core
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Why-Formality-Core?.html">1. Why Formality-Core?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/Installation.html">2. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/Hello,-world!.html">3. Hello, World!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/Numbers-and-Operators.html">4. Numbers and Operators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/Pairs.html">5. Pairs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/Pairs.html#creating-a-pair">5.1. Creating a pair</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/Pairs.html#getting-its-elements">5.2. Getting its elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/Pairs.html#nesting">5.3. Nesting</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/Lets-and-Defs.html">6. Lets and Defs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/If-and-Cpy.html">7. If and Cpy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/If-and-Cpy.html#if">7.1. If</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/If-and-Cpy.html#cpy">7.2. Cpy</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/Dups-and-Boxes.html">8. Dups and Boxes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/Dups-and-Boxes.html#measuring-complexity">8.1. Measuring complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/Dups-and-Boxes.html#boxes">8.2. Boxes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/Dups-and-Boxes.html#duplications">8.3. Duplications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/Dups-and-Boxes.html#the-stratification-condition">8.4. The stratification condition</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/Lambdas-and-Affinity.html">9. Lambdas and Affinity</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/Lambdas-and-Affinity.html#currying">9.1. Currying</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/Lambdas-and-Affinity.html#affinity">9.2. Affinity</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/Loops-and-Recursion.html">10. Loops and Recursion</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/Loops-and-Recursion.html#bounded-recursion">10.1. Bounded Recursion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/Undefined-Behavior.html">11. Undefined behavior</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">12. Datatypes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#scott-encoding">12.1. Scott-Encoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="#church-encoding">12.2. Church-Encoding</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../runtime/Formality-Net.html">13. Formality Net</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../runtime/Formality-Net.html#node-types">13.1. Node types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../runtime/Formality-Net.html#rewrite-rules">13.2. Rewrite rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="../runtime/Formality-Net.html#compilation">13.3. Compilation</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Formality-Core</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>12. Datatypes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/techniques/Datatypes.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="datatypes">
<h1>12. Datatypes<a class="headerlink" href="#datatypes" title="Permalink to this headline">¶</a></h1>
<p>Most traditional functional languages of the Haskell/ML family feature algebraic datatypes or ADTs. Those are essentially the bread-and-butter of functional programming. From Lists to Trees to Monads, every data structure in those languages is an ADT. Formality-Core does not include native ADTs; instead, it provides the building blocks for the user to assemble their own datatypes. This is important when it comes to interaction net compilation because the same data structure could be represented in different ways, with different runtime characteristics, each one having benefits and drawbacks. Being explicit about them allows the programmer to have control over the runtime behavior of their programs.</p>
<div class="section" id="scott-encoding">
<h2>12.1. Scott-Encoding<a class="headerlink" href="#scott-encoding" title="Permalink to this headline">¶</a></h2>
<p>The Scott-Encoding represents ADTs as a series of lambdas. It doesn’t involve boxes and behaves almost identically to traditional ADTs. The advantage of Scott-Encoded datatypes is that they have O(1) elimination, i.e., pattern-matching is a constant-time operation. The disadvantage is that, since Formality-Core is terminating, you can’t iterate/recurse over them directly; instead, you need to use Church-Encoded helpers. The best way to explain a λ-encoding is by example and comparison, so, here are bools, pairs, and trees, with their Haskell-equivalents:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// ::::::::::</span>
<span class="c1">// :: Bool ::</span>
<span class="c1">// ::::::::::</span>

<span class="c1">// data Bool = True | False</span>
<span class="c1">// bool_match x true false = case x of { True =&gt; true; False =&gt; false }</span>

<span class="nx">def</span> <span class="nx">True</span>       <span class="o">:</span> <span class="p">{</span><span class="kc">true</span> <span class="kc">false</span><span class="p">}</span> <span class="kc">true</span>
<span class="nx">def</span> <span class="nx">False</span>      <span class="o">:</span> <span class="p">{</span><span class="kc">true</span> <span class="kc">false</span><span class="p">}</span> <span class="kc">false</span>
<span class="nx">def</span> <span class="nx">bool_match</span> <span class="o">:</span> <span class="p">{</span><span class="nx">x</span> <span class="kc">true</span> <span class="kc">false</span><span class="p">}</span> <span class="p">(</span><span class="nx">x</span> <span class="kc">true</span> <span class="kc">false</span><span class="p">)</span>

<span class="c1">// ::::::::::</span>
<span class="c1">// :: Pair ::</span>
<span class="c1">// ::::::::::</span>

<span class="c1">// data Pair a b = Pair a b</span>
<span class="c1">// pair_match x pair = case x of { Pair a b =&gt; pair a b }</span>

<span class="nx">def</span> <span class="nx">Pair</span>       <span class="o">:</span> <span class="p">{</span><span class="nx">a</span> <span class="nx">b</span> <span class="nx">pair</span><span class="p">}</span> <span class="p">(</span><span class="nx">pair</span> <span class="nx">a</span> <span class="nx">b</span><span class="p">)</span>
<span class="nx">def</span> <span class="nx">pair_match</span> <span class="o">:</span> <span class="p">{</span><span class="nx">x</span> <span class="nx">pair</span><span class="p">}</span> <span class="p">(</span><span class="nx">x</span> <span class="p">{</span><span class="nx">a</span> <span class="nx">b</span><span class="p">}</span> <span class="p">(</span><span class="nx">pair</span> <span class="nx">a</span> <span class="nx">b</span><span class="p">))</span>

<span class="c1">// ::::::::::</span>
<span class="c1">// :: Tree ::</span>
<span class="c1">// ::::::::::</span>

<span class="c1">// data Tree a = Node (Tree a) (Tree a) | Leaf a</span>
<span class="c1">// tree_match x node leaf = case x of { Node a b =&gt; node a b; Leaf val =&gt; leaf val }</span>

<span class="nx">def</span> <span class="nx">Node</span>       <span class="o">:</span> <span class="p">{</span><span class="nx">a</span> <span class="nx">b</span> <span class="nx">node</span> <span class="nx">leaf</span><span class="p">}</span> <span class="p">(</span><span class="nx">node</span> <span class="nx">a</span> <span class="nx">b</span><span class="p">)</span>
<span class="nx">def</span> <span class="nx">Leaf</span>       <span class="o">:</span> <span class="p">{</span><span class="nx">val</span> <span class="nx">node</span> <span class="nx">leaf</span><span class="p">}</span> <span class="p">(</span><span class="nx">leaf</span> <span class="nx">val</span><span class="p">)</span>
<span class="nx">def</span> <span class="nx">tree_match</span> <span class="o">:</span> <span class="p">{</span><span class="nx">x</span> <span class="nx">node</span> <span class="nx">leaf</span><span class="p">}</span> <span class="p">(</span><span class="nx">x</span> <span class="p">{</span><span class="nx">a</span> <span class="nx">b</span><span class="p">}</span> <span class="p">(</span><span class="nx">node</span> <span class="nx">a</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span><span class="nx">val</span><span class="p">}</span> <span class="p">(</span><span class="nx">leaf</span> <span class="nx">val</span><span class="p">))</span>

<span class="c1">// ::::::::::::::</span>
<span class="c1">// :: Examples ::</span>
<span class="c1">// ::::::::::::::</span>

<span class="nx">def</span> <span class="nx">main</span><span class="o">:</span>

  <span class="kd">let</span> <span class="nx">bool_ex</span> <span class="o">=</span>
    <span class="kd">let</span> <span class="nx">bool</span>       <span class="o">=</span> <span class="nx">True</span>
    <span class="kd">let</span> <span class="nx">true_case</span>  <span class="o">=</span> <span class="s2">&quot;Bool is true&quot;</span> 
    <span class="kd">let</span> <span class="nx">false_case</span> <span class="o">=</span> <span class="s2">&quot;Bool is false&quot;</span>
    <span class="p">(</span><span class="nx">bool_match</span> <span class="nx">bool</span> <span class="nx">true_case</span> <span class="nx">false_case</span><span class="p">)</span>

  <span class="kd">let</span> <span class="nx">pair_ex</span> <span class="o">=</span>
    <span class="kd">let</span> <span class="nx">pair</span>      <span class="o">=</span> <span class="p">(</span><span class="nx">Pair</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">pair_case</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span> <span class="nx">b</span><span class="p">}</span> <span class="p">[</span><span class="s2">&quot;Pair sum is:&quot;</span><span class="p">,</span> <span class="o">|</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="o">|</span><span class="p">]</span> 
    <span class="p">(</span><span class="nx">pair_match</span> <span class="nx">pair</span> <span class="nx">pair_case</span><span class="p">)</span>

  <span class="kd">let</span> <span class="nx">tree_ex</span> <span class="o">=</span>
    <span class="kd">let</span> <span class="nx">tree</span>      <span class="o">=</span> <span class="p">(</span><span class="nx">Node</span> <span class="p">(</span><span class="nx">Leaf</span> <span class="mi">42</span><span class="p">)</span> <span class="p">(</span><span class="nx">Leaf</span> <span class="mi">64</span><span class="p">))</span>
    <span class="kd">let</span> <span class="nx">node_case</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span> <span class="nx">b</span><span class="p">}</span> <span class="s2">&quot;Tree is a Node&quot;</span>
    <span class="kd">let</span> <span class="nx">leaf_case</span> <span class="o">=</span> <span class="p">{</span><span class="nx">val</span><span class="p">}</span> <span class="s2">&quot;Tree is a Leaf&quot;</span>
    <span class="p">(</span><span class="nx">tree_match</span> <span class="p">(</span><span class="nx">Node</span> <span class="p">(</span><span class="nx">Leaf</span> <span class="mi">42</span><span class="p">)</span> <span class="p">(</span><span class="nx">Leaf</span> <span class="mi">64</span><span class="p">))</span> <span class="nx">node_case</span> <span class="nx">leaf_case</span><span class="p">)</span>

  <span class="p">[</span><span class="nx">bool_ex</span><span class="p">,</span>
  <span class="p">[</span><span class="nx">pair_ex</span><span class="p">,</span>
    <span class="nx">tree_ex</span><span class="p">]]</span>
</pre></div>
</div>
<p>Thanks to the Scott-Encoding, any Haskell or Agda program that doesn’t involve duplications or recursion can be translated directly to Formality-Core without changes. For iteration and recursion, we need the Church-Encoding.</p>
</div>
<div class="section" id="church-encoding">
<h2>12.2. Church-Encoding<a class="headerlink" href="#church-encoding" title="Permalink to this headline">¶</a></h2>
<p>The Church-Encoding is like a materialization of a Haskell fold. It involves boxes, and is used for bounded iteration and recursion. Without Church-Encodings, Formality-Core would be a boring language where all its programs could do is move/permutate stuff around and stop in linear time. They’re only required for variable-size (i.e., recursive) datatypes, since, on the fixed-size case, Church and Scott are identical. Once again, they’re better explained through examples:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>// ::::::::::
// :: List ::
// ::::::::::

// data List a = Cons a (List a) | Nil
// list_fold x cons nil = case x of { Cons x xs =&gt; cons x (list_fold xs succ zero); Nil =&gt; nil }

def Nil: {cons nil}
  dup cons = cons
  dup nil  = nil
  # nil

def Cons: {x xs cons nil}
  dup cons = cons
  dup nil  = nil
  dup x    = x
  dup xs   = (xs #cons #nil)
  # (cons x xs)

def fold_list: {x cons nil}
  (x cons nil)

// ::::::::::
// :: Tree ::
// ::::::::::

// data Tree a = Node (Tree a) (Tree a) | Leaf a
// tree_fold x node leaf = case x of { Node a b =&gt; node (tree_fold a node leaf) (tree_fold b node leaf); Leaf val =&gt; leaf val }

def Node: {a b node leaf}
  dup node = node
  dup leaf = leaf
  dup a    = (a #node #leaf)
  dup b    = (b #node #leaf)
  # (node a b)

def Leaf: {val node leaf}
  dup node = node
  dup leaf = leaf
  dup val  = val
  # (leaf val)

def fold_tree: {x node leaf}
  (x node leaf)

// ::::::::::::::
// :: Examples ::
// ::::::::::::::

def main:

  let list_ex =
    let list      = (Cons #1 (Cons #2 (Cons #3 (Cons #4 Nil))))
    let fold_cons = # {x xs} |x + xs|
    let fold_nil  = # 0
    (fold_list list fold_cons fold_nil)

  let tree_ex =
    let tree      = (Node (Node (Leaf #1) (Leaf #2)) (Node (Leaf #3) (Leaf #4)))
    let fold_node = # {a b} |a + b|
    let fold_leaf = # {val} val
    (fold_tree tree fold_node fold_leaf)

  [list_ex, tree_ex]
</pre></div>
</div>
<p>Notice how, unlike on the Scott-Encoded versions, here we are able to fold over the structures, summing all their contained values. Moreover, due to the use of boxes, elements contained by a Church-Encoded structure must always be one layer above than them, which, by consequence, means that results of folds are one layer above too.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../runtime/Formality-Net.html" class="btn btn-neutral float-right" title="13. Formality Net" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../language/Undefined-Behavior.html" class="btn btn-neutral float-left" title="11. Undefined behavior" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Sunshine Cybernetics

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>