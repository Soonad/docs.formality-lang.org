

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>5. Datatypes &mdash; Formality 0.3.91 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6. Box System" href="6.7.Boxes.html" />
    <link rel="prev" title="4. Basics" href="4.Basics.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #444053" >
          

          
            <a href="../index.html">
          

          
            
            <img src="../_static/formality-logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                3.91
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Language</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="1.Motivation.html">1. Motivation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="1.Motivation.html#optimal-substitutions">1.1. Optimal substitutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="1.Motivation.html#a-perfect-execution-model">1.2. A “perfect” execution model</a></li>
<li class="toctree-l2"><a class="reference internal" href="1.Motivation.html#a-powerful-type-theory">1.3. A powerful type-theory</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="2.Installation.html">2. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="3.Hello,-world!.html">3. Hello, World!</a><ul>
<li class="toctree-l2"><a class="reference internal" href="3.Hello,-world!.html#running-a-program">3.1. Running a program</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.Hello,-world!.html#imports">3.2. Imports</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.Hello,-world!.html#global-imports">3.3. Global imports</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.Hello,-world!.html#evaluating">3.4. Evaluating</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.Hello,-world!.html#type-checking">3.5. Type-checking</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="4.Basics.html">4. Basics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="4.Basics.html#let">4.1. Let</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.Basics.html#words">4.2. Words</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.Basics.html#if">4.3. If</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.Basics.html#pairs">4.4. Pairs</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.Basics.html#functions">4.5. Functions</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">5. Datatypes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#simple-datatypes">5.1. Simple datatypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#container-datatypes">5.2. Container datatypes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#nested-cases">5.2.1. Nested cases</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#recursive-datatypes">5.3. Recursive datatypes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#recursive-functions">5.3.1. Recursive functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#polymorphic-datatypes">5.4. Polymorphic datatypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#indexed-datatypes">5.5. Indexed datatypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#self-encodings">5.6. Self-Encodings</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="6.7.Boxes.html">6. Box System</a><ul>
<li class="toctree-l2"><a class="reference internal" href="6.7.Boxes.html#avoid-making-a-copy">6.1. Avoid making a copy.</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="6.7.Boxes.html#use-case-d-arguments">7. Use case’d arguments.</a><ul>
<li class="toctree-l2"><a class="reference internal" href="6.7.Boxes.html#make-a-manual-copy">7.1. Make a manual copy.</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.7.Boxes.html#use-boxes">7.2. Use boxes</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.7.Boxes.html#loops-and-recursion">7.3. Loops and Recursion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="8.Theorem-Proving.html">8. Theorem Proving</a><ul>
<li class="toctree-l2"><a class="reference internal" href="8.Theorem-Proving.html#equality">8.1. Equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.Theorem-Proving.html#simple-proofs">8.2. Simple proofs</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.Theorem-Proving.html#inductive-proofs">8.3. Inductive proofs</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Runtime</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../runtime/Formality-Net.html">1. Formality Net</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../runtime/Formality-Net.html#rewrite-rules">1.1. Rewrite rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#erasure">1.1.1. Erasure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#substitution">1.1.2. Substitution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#duplication">1.1.3. Duplication</a></li>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#if-then-else">1.1.4. If-Then-Else</a></li>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#num-operation">1.1.5. Num-Operation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../runtime/Formality-Net.html#compiling-fm-core-to-fm-net">1.2. Compiling FM-Core to FM-Net</a></li>
<li class="toctree-l2"><a class="reference internal" href="../runtime/Formality-Net.html#implementation">1.3. Implementation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#rewrites">1.3.1. Rewrites</a></li>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#strict-evaluation">1.3.2. Strict evaluation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#lazy-evaluation">1.3.3. Lazy evaluation</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Formality</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>5. Datatypes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/language/5.Datatypes.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="datatypes">
<h1>5. Datatypes<a class="headerlink" href="#datatypes" title="Permalink to this headline">¶</a></h1>
<p>Formality includes a powerful datatype system. A new datatype can be defined with the <code class="docutils literal notranslate"><span class="pre">T</span></code> syntax, which is similar to Haskell’s <code class="docutils literal notranslate"><span class="pre">data</span></code>, and creates global definitions for its type and constructors. To pattern-match against a value of a datatype, you must use <code class="docutils literal notranslate"><span class="pre">case/T</span></code>.</p>
<div class="section" id="simple-datatypes">
<h2>5.1. Simple datatypes<a class="headerlink" href="#simple-datatypes" title="Permalink to this headline">¶</a></h2>
<p>A simple datatype is equivalent to an enum. It can be defined and used as:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>import Base@0 open

T Suit
| clubs
| diamonds
| hearts
| spades

print_suit : {suit : Suit} -&gt; Output
  case/Suit suit
  | clubs    =&gt; print(&quot;First rule: you do not talk about Fight Club.&quot;)
  | diamonds =&gt; print(&quot;Queen shines more than diamond.&quot;)
  | hearts   =&gt; print(&quot;You always had mine.&quot;)
  | spades   =&gt; print(&quot;The only card I need is the Ace of Spades! \m/&quot;)
  : Output

main : Output
  print_suit(spades)
</pre></div>
</div>
<p>The program above creates a datatype, <code class="docutils literal notranslate"><span class="pre">Suit</span></code>, with 4 cases (constructors). It then pattern-matches a suit and outputs a different sentence depending on it. The <code class="docutils literal notranslate"><span class="pre">case</span></code> expression requires he name of the matched datatype, the matched value, each case provided with a <code class="docutils literal notranslate"><span class="pre">|</span></code>. It also requires you to annotate the type returned by the match. This is important for dependent pattern matches. Since here it coincides with the type returned by the function, you can use <code class="docutils literal notranslate"><span class="pre">case</span></code>’d arguments instead:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">print_suit</span> <span class="o">:</span> <span class="p">{</span><span class="k">case</span> <span class="nx">suit</span> <span class="o">:</span> <span class="nx">Suit</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nx">Output</span>
<span class="o">|</span> <span class="nx">clubs</span>    <span class="p">=&gt;</span> <span class="nx">print</span><span class="p">(</span><span class="s2">&quot;First rule: you do not talk about Fight Club.&quot;</span><span class="p">)</span>
<span class="o">|</span> <span class="nx">diamonds</span> <span class="p">=&gt;</span> <span class="nx">print</span><span class="p">(</span><span class="s2">&quot;Queen shines more than diamond.&quot;</span><span class="p">)</span>
<span class="o">|</span> <span class="nx">hearts</span>   <span class="p">=&gt;</span> <span class="nx">print</span><span class="p">(</span><span class="s2">&quot;You always had mine.&quot;</span><span class="p">)</span>
<span class="o">|</span> <span class="nx">spades</span>   <span class="p">=&gt;</span> <span class="nx">print</span><span class="p">(</span><span class="s2">&quot;The only card I need is the Ace of Spades! \m/&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice the <code class="docutils literal notranslate"><span class="pre">case</span></code> keyword before <code class="docutils literal notranslate"><span class="pre">suit</span></code>. This tells Formality to match <code class="docutils literal notranslate"><span class="pre">suit</span></code> directly, giving <code class="docutils literal notranslate"><span class="pre">print_suit</span></code> a Haskell-like syntax. This feature is actually quite powerful, as it will perform some handy resource management and “motive-filling” under the hoods, allowing you to write much smaller programs/proofs. Use it when possible!</p>
</div>
<div class="section" id="container-datatypes">
<h2>5.2. Container datatypes<a class="headerlink" href="#container-datatypes" title="Permalink to this headline">¶</a></h2>
<p>Datatype constructors can have fields, allowing them to store values:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">T</span> <span class="nx">Vector3D</span>
<span class="o">|</span> <span class="nx">v3</span> <span class="p">{</span><span class="nx">x</span> <span class="o">:</span> <span class="nx">Word</span><span class="p">,</span> <span class="nx">y</span> <span class="o">:</span> <span class="nx">Word</span><span class="p">,</span> <span class="nx">z</span> <span class="o">:</span> <span class="nx">Word</span><span class="p">}</span>
</pre></div>
</div>
<p>You can access its fields with a <code class="docutils literal notranslate"><span class="pre">case</span></code> syntax:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>get_x : {v : Vector3D} -&gt; Word
  case/Vector3D v
  | v3 =&gt; x
  : Word
</pre></div>
</div>
<div class="section" id="nested-cases">
<h3>5.2.1. Nested cases<a class="headerlink" href="#nested-cases" title="Permalink to this headline">¶</a></h3>
<p>When you have nested cases, you disambiguate with <code class="docutils literal notranslate"><span class="pre">^</span></code>, wich refers to a outer variable:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>sum : {v0 : Vector3D, v1 : Vector3D} -&gt; Vector3D
  case/Vector3D v0
  | v3 =&gt; case/Vector3D v1
    | v3 =&gt; v3(x + x^, y + y^, z + z^)
    : Vector3D
  : Vector3D
</pre></div>
</div>
<p>Or you can use <code class="docutils literal notranslate"><span class="pre">let</span></code>:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>sum : {a : Vector3D, b : Vector3D} -&gt; Vector3D
  case/Vector3D a
  | v3 =&gt;
    let ax = x
    let ay = y
    let az = z
    case/Vector3D b
    | v3 =&gt;
      let bx = x
      let by = y
      let bz = z
      v3(ax + bx, ay + by, az + bz)
    : Vector3D
  : Vector3D
</pre></div>
</div>
<p>Of, preferably, just use case’d arguments. It’ll allow you to access the fields with <code class="docutils literal notranslate"><span class="pre">var.field</span></code>, as in:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">sum</span> <span class="o">:</span> <span class="p">{</span><span class="k">case</span> <span class="nx">a</span> <span class="o">:</span> <span class="nx">Vector3D</span><span class="p">,</span> <span class="k">case</span> <span class="nx">b</span> <span class="o">:</span> <span class="nx">Vector3D</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nx">Vector3D</span>
<span class="o">|</span> <span class="nx">v3</span> <span class="nx">v3</span> <span class="p">=&gt;</span> <span class="nx">v3</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">b</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">b</span><span class="p">.</span><span class="nx">y</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">z</span> <span class="o">+</span> <span class="nx">b</span><span class="p">.</span><span class="nx">z</span><span class="p">)</span>
</pre></div>
</div>
<p>As you can see, case’d arguments will often be much terser than case-expressions.</p>
</div>
</div>
<div class="section" id="recursive-datatypes">
<h2>5.3. Recursive datatypes<a class="headerlink" href="#recursive-datatypes" title="Permalink to this headline">¶</a></h2>
<p>Datatypes can contain fields of the same type. An example is <code class="docutils literal notranslate"><span class="pre">Nat</span></code>:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">T</span> <span class="nx">Nat</span>
<span class="o">|</span> <span class="nx">succ</span> <span class="p">{</span><span class="nx">pred</span> <span class="o">:</span> <span class="nx">Nat</span><span class="p">}</span>
<span class="o">|</span> <span class="nx">zero</span>

<span class="c1">// Returns 1 if n &gt; 0, otherwise returns 0</span>
<span class="nx">signal</span> <span class="o">:</span> <span class="p">{</span><span class="k">case</span> <span class="nx">n</span> <span class="o">:</span> <span class="nx">Nat</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nx">Nat</span>
<span class="o">|</span> <span class="nx">succ</span> <span class="p">=&gt;</span> <span class="nx">succ</span><span class="p">(</span><span class="nx">zero</span><span class="p">)</span>
<span class="o">|</span> <span class="nx">zero</span> <span class="p">=&gt;</span> <span class="nx">zero</span>
</pre></div>
</div>
<p>Since Nat in particular is so common, there is a syntax-sugar for it: <code class="docutils literal notranslate"><span class="pre">0n3</span></code>, which expands to <code class="docutils literal notranslate"><span class="pre">succ(succ(succ(zero)))</span></code>.</p>
<div class="section" id="recursive-functions">
<h3>5.3.1. Recursive functions<a class="headerlink" href="#recursive-functions" title="Permalink to this headline">¶</a></h3>
<p>Of course, recursive datatypes aren’t very useful without recursive functions. Since the underlying calculus behind Formality is terminating, you can’t write those directly, as in:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">mul2</span> <span class="o">:</span> <span class="p">{</span><span class="k">case</span> <span class="nx">n</span> <span class="o">:</span> <span class="nx">Nat</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nx">Nat</span>
<span class="o">|</span> <span class="nx">succ</span> <span class="p">=&gt;</span> <span class="nx">succ</span><span class="p">(</span><span class="nx">succ</span><span class="p">(</span><span class="nx">mul2</span><span class="p">(</span><span class="nx">n</span><span class="p">)))</span>
<span class="o">|</span> <span class="nx">zero</span> <span class="p">=&gt;</span> <span class="nx">zero</span>
</pre></div>
</div>
<p>Instead, you must 1. append a <code class="docutils literal notranslate"><span class="pre">!</span></code> to its name and type, to make a “boxed definition”, 2. annotate it with an extra variable, <code class="docutils literal notranslate"><span class="pre">N</span></code>, that tracks of the number of calls, 3. add a “halt-case” with <code class="docutils literal notranslate"><span class="pre">*</span></code>, which will be forcedly returned if the function “runs out of gas”:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="o">!</span><span class="nx">mul2</span><span class="o">*</span><span class="nx">N</span> <span class="o">:</span> <span class="o">!</span><span class="p">{</span><span class="k">case</span> <span class="nx">n</span> <span class="o">:</span> <span class="nx">Nat</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nx">Nat</span>
<span class="o">|</span> <span class="nx">succ</span> <span class="p">=&gt;</span> <span class="nx">succ</span><span class="p">(</span><span class="nx">succ</span><span class="p">(</span><span class="nx">mul2</span><span class="p">(</span><span class="nx">n</span><span class="p">)))</span>
<span class="o">|</span> <span class="nx">zero</span> <span class="p">=&gt;</span> <span class="nx">zero</span>
<span class="o">*</span> <span class="nx">zero</span>
</pre></div>
</div>
<p>Then you can use it inside other boxed definitions by setting a maximum number of calls with <code class="docutils literal notranslate"><span class="pre">*</span></code>:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="o">!</span><span class="nx">main</span> <span class="o">:</span> <span class="o">!</span><span class="nx">Nat</span>
  <span class="o">&lt;</span><span class="nx">mul2</span><span class="o">*</span><span class="mi">65536</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">succ</span><span class="p">(</span><span class="nx">succ</span><span class="p">(</span><span class="nx">zero</span><span class="p">)))</span>
</pre></div>
</div>
<p>Or you can hide the number and Formality will default to a number so big it can never be reached in practice.</p>
<p>The reason things are this way is that recursive functions are desugared to eliminations of the inductive hypothesis of Church-encoded <code class="docutils literal notranslate"><span class="pre">Nat</span></code>s, which is the closest to recursion that the underlying theory offers, but requires a max number of calls and a “halt-case”.  Note that 1. this results in no loss of performance, 2. Formality functions can have bounds so high that they’ll never be reached in practice. So, from a practical point of view, Formality is no less powerful than, say, JavaScript, which is limited by the max stack size, your computer’s memory/CPU, etc.</p>
<p>In any case, you don’t need to understand any of that to use the language. Just remember that recursive functions have a slightly different syntax. For the nerds around, we’ll explain those interesting details in later sections.</p>
</div>
</div>
<div class="section" id="polymorphic-datatypes">
<h2>5.4. Polymorphic datatypes<a class="headerlink" href="#polymorphic-datatypes" title="Permalink to this headline">¶</a></h2>
<p>Polymorphic datatypes allow us to create multiple instances of the same datatype with different contained types.</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>import Base@0 open

T Vector3D {T : Type}
| v3 {x : T, y : T, z : T} 

main : [:Nat, Word]
  let a = v3(~Nat, 0n1, 0n2, 0n3)
  let b = v3(~Word, 1, 2, 3)

  let ax = case/Vector3D a | v3 =&gt; x : Nat
  let bx = case/Vector3D b | v3 =&gt; x : Word

  [ax, bx]
</pre></div>
</div>
<p>The program above creates two 3D vectors, the first one storing <code class="docutils literal notranslate"><span class="pre">Nat</span></code>s and the second one storing <code class="docutils literal notranslate"><span class="pre">Word</span></code>s. The polymorphic variable <code class="docutils literal notranslate"><span class="pre">T</span></code>, defined with the <code class="docutils literal notranslate"><span class="pre">{}</span></code> syntax, allowed us to reuse the same definition of <code class="docutils literal notranslate"><span class="pre">Vector3D</span></code> for both contained types. With this, we can also create the popular functional List type:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">T</span> <span class="nx">List</span> <span class="p">{</span><span class="nx">T</span> <span class="o">:</span> <span class="nx">Type</span><span class="p">}</span>
<span class="o">|</span> <span class="nx">cons</span> <span class="p">{</span><span class="nx">head</span> <span class="o">:</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">tail</span> <span class="o">:</span> <span class="nx">List</span><span class="p">(</span><span class="nx">T</span><span class="p">)}</span>
<span class="o">|</span> <span class="nx">nil</span>

<span class="c1">// Returns all but the first element</span>
<span class="nx">tail</span> <span class="o">:</span> <span class="p">{</span><span class="o">~</span><span class="nx">T</span> <span class="o">:</span> <span class="nx">Type</span><span class="p">,</span> <span class="k">case</span> <span class="nx">list</span> <span class="o">:</span> <span class="nx">List</span><span class="p">(</span><span class="nx">T</span><span class="p">)}</span> <span class="o">-&gt;</span> <span class="nx">List</span><span class="p">(</span><span class="nx">T</span><span class="p">)</span>
<span class="o">|</span> <span class="nx">cons</span> <span class="p">=&gt;</span> <span class="nx">list</span><span class="p">.</span><span class="nx">tail</span>
<span class="o">|</span> <span class="nx">nil</span>  <span class="p">=&gt;</span> <span class="nx">nil</span><span class="p">(</span><span class="o">~</span><span class="nx">T</span><span class="p">)</span>

<span class="nx">main</span> <span class="o">:</span> <span class="nx">List</span><span class="p">(</span><span class="nx">Word</span><span class="p">)</span>
  <span class="nx">tail</span><span class="p">(</span><span class="o">~</span><span class="nx">Word</span><span class="p">,</span> <span class="nx">cons</span><span class="p">(</span><span class="o">~</span><span class="nx">Word</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">cons</span><span class="p">(</span><span class="o">~</span><span class="nx">Word</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">cons</span><span class="p">(</span><span class="o">~</span><span class="nx">Word</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">nil</span><span class="p">(</span><span class="o">~</span><span class="nx">Word</span><span class="p">)))))</span>
</pre></div>
</div>
<p>Notice that, since Formality has no implicict arguments, you need to explicitly instantiate constructors with <code class="docutils literal notranslate"><span class="pre">(~Word)</span></code>. To reduce the noise, you can use <code class="docutils literal notranslate"><span class="pre">let</span></code>:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">main</span> <span class="o">:</span> <span class="nx">List</span><span class="p">(</span><span class="nx">Word</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nx">tail</span> <span class="o">=</span> <span class="nx">tail</span><span class="p">(</span><span class="o">~</span><span class="nx">Word</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nx">cons</span> <span class="o">=</span> <span class="nx">cons</span><span class="p">(</span><span class="o">~</span><span class="nx">Word</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nx">nil</span>  <span class="o">=</span> <span class="nx">nil</span><span class="p">(</span><span class="o">~</span><span class="nx">Word</span><span class="p">)</span>
  <span class="nx">tail</span><span class="p">(</span><span class="nx">cons</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">cons</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nx">cons</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nx">nil</span><span class="p">))))</span>
</pre></div>
</div>
<p>But, since <code class="docutils literal notranslate"><span class="pre">List</span></code> is so common, there is a built-in syntax-sugar for it, the dollar sign:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">main</span> <span class="o">:</span> <span class="nx">List</span><span class="p">(</span><span class="nx">Word</span><span class="p">)</span>
  <span class="nx">tail</span><span class="p">(</span><span class="o">~</span><span class="nx">Word</span><span class="p">,</span> <span class="nx">Word$</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="indexed-datatypes">
<h2>5.5. Indexed datatypes<a class="headerlink" href="#indexed-datatypes" title="Permalink to this headline">¶</a></h2>
<p>Indexes are like polymorphic variables, except that they can change as the structure grows. For example, a Vector is like a List, except that its type stores its own length:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>import Base@0 open

T Vector {T : Type} (len : Nat)
| vcons {~len : Nat, head : T, tail : Vector(T, len)} (succ(len))
| vnil                                                (zero)

main : Vector(String, 0n3)
  vcons(~String, ~0n2, &quot;ichi&quot;,
  vcons(~String, ~0n1, &quot;ni&quot;,
  vcons(~String, ~0n0, &quot;san&quot;,
  vnil(~String))))
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">()</span></code> syntax was used to apply the indexes to the returned type of each constructor. For example, <code class="docutils literal notranslate"><span class="pre">|</span> <span class="pre">vnil</span> <span class="pre">(zero)</span></code> would be equivalent to <code class="docutils literal notranslate"><span class="pre">vnil</span> <span class="pre">:</span> <span class="pre">Vector(T,</span> <span class="pre">zero)</span></code> in Agda. In this example, <code class="docutils literal notranslate"><span class="pre">main</span></code> has the type <code class="docutils literal notranslate"><span class="pre">Vector(String,</span> <span class="pre">0n3)</span></code>, meaning it is a vector with exactly 3 strings. If we used <code class="docutils literal notranslate"><span class="pre">vcons</span></code> again, the type would change to <code class="docutils literal notranslate"><span class="pre">Vector(String,</span> <span class="pre">0n4)</span></code>. This feature allows us to annotate our data with very rich static information, allowing us to prevent a wide range of bugs. For example, here is a <code class="docutils literal notranslate"><span class="pre">vhead</span></code> function that can only be called in non-empty vectors:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>import Base@0 open

T Vector {T : Type} (len : Nat)
| vcons {~len : Nat, head : T, tail : Vector(T, len)} (succ(len))
| vnil                                                (zero)

vhead : {~T : Type, ~n : Nat, vector : Vector(T, succ(n))} -&gt; T
  case/Vector vector
  | vcons  =&gt; head
  | vnil   =&gt; 1337
  : case/Nat len
    | succ =&gt; T
    | zero =&gt; Word
    : Type

main : Output
  let vec =
    vcons(~String, ~0n2, &quot;uno&quot;,
    vcons(~String, ~0n1, &quot;dos&quot;,
    vcons(~String, ~0n0, &quot;tres&quot;,
    vnil(~String))))

  print(vhead(~String, ~0n2, vec))
</pre></div>
</div>
<p>To understand how it works, notice that the return-type of the <code class="docutils literal notranslate"><span class="pre">case</span></code> expression is allowed to access <code class="docutils literal notranslate"><span class="pre">len</span></code>. This allows Formality to specialize the expected type of each case. On <code class="docutils literal notranslate"><span class="pre">vcons</span></code>, the length is <code class="docutils literal notranslate"><span class="pre">succ(...)</span></code>, so we must provide an element of type <code class="docutils literal notranslate"><span class="pre">T</span></code>. On <code class="docutils literal notranslate"><span class="pre">vnil</span></code>, the length is <code class="docutils literal notranslate"><span class="pre">zero</span></code>, so we must provide any arbitrary <code class="docutils literal notranslate"><span class="pre">Word</span></code>. Then, the return type of the case expression itself is computed based on the index of the matched <code class="docutils literal notranslate"><span class="pre">vector</span></code>, which is <code class="docutils literal notranslate"><span class="pre">succ(n)</span></code>. Since that is positive, the return type is always <code class="docutils literal notranslate"><span class="pre">T</span></code>, i.e., Formality knows it will never fall on the <code class="docutils literal notranslate"><span class="pre">vnil</span></code> case. Calling <code class="docutils literal notranslate"><span class="pre">vhead</span></code> with an empty vector is impossible because we’d need an <code class="docutils literal notranslate"><span class="pre">n</span></code> such that <code class="docutils literal notranslate"><span class="pre">succ(n)</span></code> is <code class="docutils literal notranslate"><span class="pre">zero</span></code>, but there is no such natural number.</p>
<p>Of course, since the length annotation is used only for type-checking purposes, computing it at runtime would be wasteful. That’s why we use <code class="docutils literal notranslate"><span class="pre">~</span></code>. This allows the length to be dropped from the compiled output, avoiding any extra runtime cost.</p>
</div>
<div class="section" id="self-encodings">
<h2>5.6. Self-Encodings<a class="headerlink" href="#self-encodings" title="Permalink to this headline">¶</a></h2>
<p>Interestingly, none of the features above are part of Formality’s type theory. Instead, they are lightweight syntax-sugars that elaborate to plain-old lambdas. To be specific, a datatype is encoded as is own inductive hypothesis, with “self-types”. For example, the Bool datatype desugars to:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">Bool</span> <span class="o">:</span> <span class="nx">Type</span>
  <span class="nx">$self</span>
  <span class="p">{</span> <span class="o">~</span><span class="nx">P</span>    <span class="o">:</span> <span class="p">{</span><span class="nx">x</span> <span class="o">:</span> <span class="nx">Bool</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nx">Type</span>
  <span class="p">,</span> <span class="kc">true</span>  <span class="o">:</span> <span class="nx">P</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
  <span class="p">,</span> <span class="kc">false</span> <span class="o">:</span> <span class="nx">P</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
  <span class="p">}</span> <span class="o">-&gt;</span> <span class="nx">P</span><span class="p">(</span><span class="nx">self</span><span class="p">)</span>

<span class="kc">true</span> <span class="o">:</span> <span class="nx">Bool</span>
  <span class="k">new</span><span class="p">(</span><span class="o">~</span><span class="nx">Bool</span><span class="p">){</span><span class="o">~</span><span class="nx">P</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">}</span> <span class="kc">true</span>

<span class="kc">false</span> <span class="o">:</span> <span class="nx">Bool</span>
  <span class="k">new</span><span class="p">(</span><span class="o">~</span><span class="nx">Bool</span><span class="p">){</span><span class="o">~</span><span class="nx">P</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">}</span> <span class="kc">false</span>

<span class="nx">case_of</span> <span class="o">:</span> <span class="p">{</span><span class="nx">b</span> <span class="o">:</span> <span class="nx">Bool</span><span class="p">,</span> <span class="o">~</span><span class="nx">P</span> <span class="o">:</span> <span class="p">{</span><span class="nx">x</span> <span class="o">:</span> <span class="nx">Bool</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nx">Type</span><span class="p">,</span> <span class="nx">t</span> <span class="o">:</span> <span class="nx">P</span><span class="p">(</span><span class="kc">true</span><span class="p">),</span> <span class="nx">f</span> <span class="o">:</span> <span class="nx">P</span><span class="p">(</span><span class="kc">false</span><span class="p">)}</span> <span class="o">-&gt;</span> <span class="nx">P</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
  <span class="p">(</span><span class="o">%</span><span class="nx">b</span><span class="p">)(</span><span class="o">~</span><span class="nx">P</span><span class="p">,</span> <span class="nx">t</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">$self</span> <span class="pre">...</span></code>, <code class="docutils literal notranslate"><span class="pre">new(~T)</span> <span class="pre">val</span></code> and <code class="docutils literal notranslate"><span class="pre">%b</span></code> are the type, introduction, and elimination of self-types, respectively. You can see how any datatype is encoded under the hoods by asking <code class="docutils literal notranslate"><span class="pre">fm</span></code> to evaluate its type, as in, <code class="docutils literal notranslate"><span class="pre">fm</span> <span class="pre">any_file.Bool</span></code> or <code class="docutils literal notranslate"><span class="pre">fm</span> <span class="pre">any_file.Nat</span></code>. While you probably won’t need to deal with self-encodings yourself, knowing how they work is valuable, since it allows you to express types not covered by the built-in syntax.</p>
<p><strong>TODO</strong>: write a brief explanation on how Self-Types work (although I think it should be self-explanatory from this example!).</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="6.7.Boxes.html" class="btn btn-neutral float-right" title="6. Box System" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="4.Basics.html" class="btn btn-neutral float-left" title="4. Basics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Ethereum Foundation and Sunshine Cybernetics

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>