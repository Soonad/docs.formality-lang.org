

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>8. Theorem Proving &mdash; Formality 0.3.91 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="1. Formality Net" href="../runtime/Formality-Net.html" />
    <link rel="prev" title="6. Box System" href="6.7.Boxes.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #444053" >
          

          
            <a href="../index.html">
          

          
            
            <img src="../_static/formality-logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                3.91
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Language</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="1.Motivation.html">1. Motivation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="1.Motivation.html#optimal-substitutions">1.1. Optimal substitutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="1.Motivation.html#a-perfect-execution-model">1.2. A “perfect” execution model</a></li>
<li class="toctree-l2"><a class="reference internal" href="1.Motivation.html#a-powerful-type-theory">1.3. A powerful type-theory</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="2.Installation.html">2. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="3.Hello,-world!.html">3. Hello, World!</a><ul>
<li class="toctree-l2"><a class="reference internal" href="3.Hello,-world!.html#running-a-program">3.1. Running a program</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.Hello,-world!.html#imports">3.2. Imports</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.Hello,-world!.html#global-imports">3.3. Global imports</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.Hello,-world!.html#evaluating">3.4. Evaluating</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.Hello,-world!.html#type-checking">3.5. Type-checking</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="4.Basics.html">4. Basics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="4.Basics.html#let">4.1. Let</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.Basics.html#words">4.2. Words</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.Basics.html#if">4.3. If</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.Basics.html#pairs">4.4. Pairs</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.Basics.html#functions">4.5. Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="5.Datatypes.html">5. Datatypes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="5.Datatypes.html#simple-datatypes">5.1. Simple datatypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.Datatypes.html#container-datatypes">5.2. Container datatypes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="5.Datatypes.html#nested-cases">5.2.1. Nested cases</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="5.Datatypes.html#recursive-datatypes">5.3. Recursive datatypes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="5.Datatypes.html#recursive-functions">5.3.1. Recursive functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="5.Datatypes.html#polymorphic-datatypes">5.4. Polymorphic datatypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.Datatypes.html#indexed-datatypes">5.5. Indexed datatypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.Datatypes.html#self-encodings">5.6. Self-Encodings</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="6.7.Boxes.html">6. Box System</a><ul>
<li class="toctree-l2"><a class="reference internal" href="6.7.Boxes.html#avoid-making-a-copy">6.1. Avoid making a copy.</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="6.7.Boxes.html#use-case-d-arguments">7. Use case’d arguments.</a><ul>
<li class="toctree-l2"><a class="reference internal" href="6.7.Boxes.html#make-a-manual-copy">7.1. Make a manual copy.</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.7.Boxes.html#use-boxes">7.2. Use boxes</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.7.Boxes.html#loops-and-recursion">7.3. Loops and Recursion</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">8. Theorem Proving</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#equality">8.1. Equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simple-proofs">8.2. Simple proofs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inductive-proofs">8.3. Inductive proofs</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Runtime</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../runtime/Formality-Net.html">1. Formality Net</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../runtime/Formality-Net.html#rewrite-rules">1.1. Rewrite rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#erasure">1.1.1. Erasure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#substitution">1.1.2. Substitution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#duplication">1.1.3. Duplication</a></li>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#if-then-else">1.1.4. If-Then-Else</a></li>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#num-operation">1.1.5. Num-Operation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../runtime/Formality-Net.html#compiling-fm-core-to-fm-net">1.2. Compiling FM-Core to FM-Net</a></li>
<li class="toctree-l2"><a class="reference internal" href="../runtime/Formality-Net.html#implementation">1.3. Implementation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#rewrites">1.3.1. Rewrites</a></li>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#strict-evaluation">1.3.2. Strict evaluation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#lazy-evaluation">1.3.3. Lazy evaluation</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Formality</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>8. Theorem Proving</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/language/8.Theorem-Proving.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="theorem-proving">
<h1>8. Theorem Proving<a class="headerlink" href="#theorem-proving" title="Permalink to this headline">¶</a></h1>
<p>This article is a draft.</p>
<div class="section" id="equality">
<h2>8.1. Equality<a class="headerlink" href="#equality" title="Permalink to this headline">¶</a></h2>
<p>TODO</p>
</div>
<div class="section" id="simple-proofs">
<h2>8.2. Simple proofs<a class="headerlink" href="#simple-proofs" title="Permalink to this headline">¶</a></h2>
<p>Let’s prove a theorem about the boolean <code class="docutils literal notranslate"><span class="pre">not</span></code>:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>import Base@0 open

main : {b : Bool} -&gt; not(not(b)) == b
  ?
</pre></div>
</div>
<p>Evaluate it using <code class="docutils literal notranslate"><span class="pre">fm</span> <span class="pre">-t</span> <span class="pre">&lt;file&gt;/main</span></code> and the type checker complains:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>Type mismatch.
- Found type... Hole
- Instead of... <span class="o">(</span>not<span class="o">(</span>not<span class="o">(</span>b<span class="o">))</span> <span class="o">==</span> b<span class="o">)</span>
- When checking ?
- On expression <span class="o">{</span>b<span class="o">}</span> <span class="o">=</span>&gt; ?
- With the following context:
- b : Bool
</pre></div>
</div>
<p>Let’s pattern-match on <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>import Base@0 open

main : {b : Bool} -&gt; not(not(b)) == b
  case/Bool b
  | true  =&gt; ?
  | false =&gt; ?
  : not(not(b)) == b
</pre></div>
</div>
<p>Not helpful:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>Type mismatch.
- Found type... Hole
- Instead of... <span class="o">(</span>not<span class="o">(</span>not<span class="o">(</span>b<span class="o">))</span> <span class="o">==</span> b<span class="o">)</span>
- When checking ?
- On expression <span class="o">(</span>%b<span class="o">)(</span>~<span class="o">{</span>self<span class="o">}</span> <span class="o">=</span>&gt; <span class="o">(</span>not<span class="o">(</span>not<span class="o">(</span>b<span class="o">))</span> <span class="o">==</span> b<span class="o">)</span>, ?<span class="o">)</span>
- With the following context:
- b : Bool
</pre></div>
</div>
<p>Using <code class="docutils literal notranslate"><span class="pre">self</span></code> on the motive:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>import Base@0 open

main : {b : Bool} -&gt; not(not(b)) == b
  case/Bool b
  | true  =&gt; ?
  | false =&gt; ?
  : not(not(self)) == self
</pre></div>
</div>
<p>Progress, <code class="docutils literal notranslate"><span class="pre">b</span></code>s is specialized <code class="docutils literal notranslate"><span class="pre">true</span></code> on the expected type of the <code class="docutils literal notranslate"><span class="pre">true</span></code> branch:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">Type</span> <span class="nx">mismatch</span><span class="p">.</span>
<span class="o">-</span> <span class="nx">Found</span> <span class="nx">type</span><span class="p">...</span> <span class="nx">Hole</span>
<span class="o">-</span> <span class="nx">Instead</span> <span class="k">of</span><span class="p">...</span> <span class="p">(</span><span class="nx">not</span><span class="p">(</span><span class="nx">not</span><span class="p">(</span><span class="kc">true</span><span class="p">))</span> <span class="o">==</span> <span class="kc">true</span><span class="p">)</span>
<span class="o">-</span> <span class="nx">When</span> <span class="nx">checking</span> <span class="o">?</span>
<span class="o">-</span> <span class="nx">On</span> <span class="nx">expression</span> <span class="p">(</span><span class="o">%</span><span class="nx">b</span><span class="p">)(</span><span class="o">~</span><span class="p">{</span><span class="nx">self</span><span class="p">}</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="nx">not</span><span class="p">(</span><span class="nx">not</span><span class="p">(</span><span class="nx">self</span><span class="p">))</span> <span class="o">==</span> <span class="nx">self</span><span class="p">),</span> <span class="o">?</span><span class="p">)</span>
<span class="o">-</span> <span class="nx">With</span> <span class="nx">the</span> <span class="nx">following</span> <span class="nx">context</span><span class="o">:</span>
<span class="o">-</span> <span class="nx">b</span> <span class="o">:</span> <span class="nx">Bool</span>
</pre></div>
</div>
<p>If we reduce both sides, we get the same expression: <code class="docutils literal notranslate"><span class="pre">{true,</span> <span class="pre">false}</span> <span class="pre">=&gt;</span> <span class="pre">true</span></code>. In this case, we can use <code class="docutils literal notranslate"><span class="pre">refl</span></code>:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>import Base@0 open

main : {b : Bool} -&gt; not(not(b)) == b
  case/Bool b
  | true  =&gt; refl(~true)
  | false =&gt; ?
  : not(not(self)) == self
</pre></div>
</div>
<p>Progress, compiler now complains about the <code class="docutils literal notranslate"><span class="pre">false</span></code> branch:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>Type mismatch.
- Found type... Hole
- Instead of... <span class="o">(</span>not<span class="o">(</span>not<span class="o">(</span><span class="nb">false</span><span class="o">))</span> <span class="o">==</span> <span class="nb">false</span><span class="o">)</span>
- When checking ?
- On expression <span class="o">(</span>%b<span class="o">)(</span>~<span class="o">{</span>self<span class="o">}</span> <span class="o">=</span>&gt; <span class="o">(</span>not<span class="o">(</span>not<span class="o">(</span>self<span class="o">))</span> <span class="o">==</span> self<span class="o">)</span>, refl<span class="o">(</span>~true<span class="o">)</span>, ?<span class="o">)</span>
- With the following context:
- b : Bool
</pre></div>
</div>
<p>We can do the same:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>import Base@0 open

main : {b : Bool} -&gt; not(not(b)) == b
  case/Bool b
  | true  =&gt; refl(~true)
  | false =&gt; refl(~false)
  : not(not(self)) == self
</pre></div>
</div>
<p>No type error. Our proof is complete! Note that, if we used <code class="docutils literal notranslate"><span class="pre">case</span></code>’d args, Formality would fill the <code class="docutils literal notranslate"><span class="pre">self</span></code> on the motive for us. The proof becomes just:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>import Base@0 open

main : {case b : Bool} -&gt; not(not(b)) == b
| true  =&gt; refl(~true)
| false =&gt; refl(~false)
</pre></div>
</div>
</div>
<div class="section" id="inductive-proofs">
<h2>8.3. Inductive proofs<a class="headerlink" href="#inductive-proofs" title="Permalink to this headline">¶</a></h2>
<p>Let’s prove a similar theorem, but for negation on arbitrary-length bit-strings instead of plain booleans:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>import Base@0 open

T Bits
| b0 {pred : Bits}
| b1 {pred : Bits}
| be

!bnot*n : !{*bits : Bits} -&gt; Bits
  (case/Bits bits
  | b0    =&gt; {bnot} b1(bnot(pred))
  | b1    =&gt; {bnot} b0(bnot(pred))
  | be    =&gt; {bnot} be
  : {bnot : {bits : Bits} -&gt; Bits} -&gt; Bits)(bnot)
</pre></div>
</div>
<p>Start with the theorem we want to prove:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>!main*n : !{bits : Bits} -&gt; -#(bnot(n))(-#(bnot(n))(bits)) == bits
  ?
  * ?
</pre></div>
</div>
<p>Remember that <code class="docutils literal notranslate"><span class="pre">*</span></code> is mandatory on recursive definition to provide the base-case. TODO: explain why the <code class="docutils literal notranslate"><span class="pre">-#</span></code>s on the type.</p>
<p>The type checker complains:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">Type</span> <span class="nx">mismatch</span><span class="p">.</span>
<span class="o">-</span> <span class="nx">Found</span> <span class="nx">type</span><span class="p">...</span> <span class="nx">Hole</span>
<span class="o">-</span> <span class="nx">Instead</span> <span class="k">of</span><span class="p">...</span> <span class="nx">bnot</span><span class="p">(</span><span class="nx">step</span><span class="p">(</span><span class="nx">n</span><span class="p">),</span> <span class="nx">bnot</span><span class="p">(</span><span class="nx">step</span><span class="p">(</span><span class="nx">n</span><span class="p">),</span> <span class="nx">bits</span><span class="p">))</span> <span class="o">==</span> <span class="nx">bits</span>
<span class="o">-</span> <span class="nx">When</span> <span class="nx">checking</span> <span class="o">?</span>
<span class="o">-</span> <span class="nx">On</span> <span class="nx">expression</span> <span class="p">{</span><span class="nx">bits</span><span class="p">}</span> <span class="p">=&gt;</span> <span class="o">?</span>
<span class="o">-</span> <span class="nx">With</span> <span class="nx">the</span> <span class="nx">following</span> <span class="nx">context</span><span class="o">:</span>
<span class="o">-</span> <span class="nx">n</span>    <span class="o">:</span> <span class="nx">Ind</span>
<span class="o">-</span> <span class="nx">n</span>    <span class="o">:</span> <span class="nx">Ind</span>
<span class="o">-</span> <span class="nx">main</span> <span class="o">:</span> <span class="p">{</span><span class="nx">bits</span> <span class="o">:</span> <span class="nx">Bits</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nx">bnot</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">bnot</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">bits</span><span class="p">))</span> <span class="o">==</span> <span class="nx">bits</span>
<span class="o">-</span> <span class="nx">bits</span> <span class="o">:</span> <span class="nx">Bits</span>
</pre></div>
</div>
<p>Notice that:</p>
<ol class="simple">
<li>It asks for <code class="docutils literal notranslate"><span class="pre">P(step(n))</span></code> instead of <code class="docutils literal notranslate"><span class="pre">P(n)</span></code>.</li>
<li>We have, on context, <code class="docutils literal notranslate"><span class="pre">main</span></code>, which gives us <code class="docutils literal notranslate"><span class="pre">P(n)</span></code>.</li>
</ol>
<p>That’s because the body of a recursive function is actually the step case of inductive proof, so all we need to do is, assuming <code class="docutils literal notranslate"><span class="pre">P(n)</span></code>, prove <code class="docutils literal notranslate"><span class="pre">P(step(n))</span></code>!</p>
<p>Let’s match against <code class="docutils literal notranslate"><span class="pre">bits</span></code>, using <code class="docutils literal notranslate"><span class="pre">self</span></code> on the motive:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>!main*n : !{bits : Bits} -&gt; -#(bnot(n))(-#(bnot(n))(bits)) == bits
  case/Bits bits
  | b0 =&gt; ?
  | b1 =&gt; ?
  | be =&gt; ?
  : -#(bnot(step(n)))(-#(bnot(step(n)))(self)) == self
  * ?
</pre></div>
</div>
<p>Now the complaint becomes:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>Type mismatch.
- Found type... Hole
- Instead of... bnot<span class="o">(</span>step<span class="o">(</span>n<span class="o">)</span>, bnot<span class="o">(</span>step<span class="o">(</span>n<span class="o">)</span>, b0<span class="o">(</span>pred<span class="o">)))</span> <span class="o">==</span> b0<span class="o">(</span>pred<span class="o">)</span>
- When checking ?
- On expression <span class="o">{</span>bits<span class="o">}</span> <span class="o">=</span>&gt; ?
- With the following context:
- n    : Ind
- n    : Ind
- main : <span class="o">{</span>bits : Bits<span class="o">}</span> -&gt; bnot<span class="o">(</span>n, bnot<span class="o">(</span>n, bits<span class="o">))</span> <span class="o">==</span> bits
- bits : Bits
- pred : Bits
</pre></div>
</div>
<p>This is better because now it expects <code class="docutils literal notranslate"><span class="pre">b0(pred)</span></code> instead of just <code class="docutils literal notranslate"><span class="pre">bits</span></code> . This allows the left-side of the equation to be reduced to:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">b0</span><span class="p">(</span><span class="nx">bnot</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">bnot</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">pred</span><span class="p">)))</span> <span class="o">==</span> <span class="nx">b0</span><span class="p">(</span><span class="nx">pred</span><span class="p">)</span>
</pre></div>
</div>
<p>This is perfect because we can use the inductive hypothesis to get this same equation, without the <code class="docutils literal notranslate"><span class="pre">b0</span></code>s. As in, we need to go…</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">from</span> <span class="o">:</span>    <span class="nx">bnot</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">bnot</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">bs</span><span class="p">))</span>  <span class="o">==</span> <span class="nx">b0</span><span class="p">(</span><span class="nx">bs</span><span class="p">)</span>
<span class="nx">to</span>   <span class="o">:</span> <span class="nx">b0</span><span class="p">(</span><span class="nx">bnot</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">bnot</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">bs</span><span class="p">)))</span> <span class="o">==</span>    <span class="nx">bs</span>
</pre></div>
</div>
<p>All we need is to add <code class="docutils literal notranslate"><span class="pre">b0</span></code> on both sides. We can do it with <code class="docutils literal notranslate"><span class="pre">cong</span></code>, from the base libraries (<code class="docutils literal notranslate"><span class="pre">Base&#64;0</span></code>):</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>!main*n : !{bits : Bits} -&gt; -#(bnot(n))(-#(bnot(n))(bits)) == bits
  case/Bits bits
  | b0 =&gt; cong(~Bits, ~Bits, ~(-#(bnot(n)))((-#(bnot(n)))(pred)), ~pred, ~b0, ~main(pred))
  | b1 =&gt; ?
  | be =&gt; ?
  : -#(bnot(step(n)))(-#(bnot(step(n)))(self)) == self
  * ?
</pre></div>
</div>
<p>TODO: should we have a built-in syntax to simplify <code class="docutils literal notranslate"><span class="pre">cong</span></code>?</p>
<p>Now the checker complains about the <code class="docutils literal notranslate"><span class="pre">b1</span></code> case:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>Type mismatch.
- Found type... Hole
- Instead of... bnot<span class="o">(</span>step<span class="o">(</span>n<span class="o">)</span>, bnot<span class="o">(</span>step<span class="o">(</span>n<span class="o">)</span>, b1<span class="o">(</span>pred<span class="o">)))</span> <span class="o">==</span> b1<span class="o">(</span>pred<span class="o">)</span>
- When checking ?
- On expression <span class="o">{</span>pred<span class="o">}</span> <span class="o">=</span>&gt; ?
- With the following context:
- n    : Ind
- n    : Ind
- main : <span class="o">{</span>bits : Bits<span class="o">}</span> -&gt; bnot<span class="o">(</span>n, bnot<span class="o">(</span>n, bits<span class="o">))</span> <span class="o">==</span> bits
- bits : Bits
- pred : Bits
</pre></div>
</div>
<p>We can easily complete this proof now:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>!main*n : !{bits : Bits} -&gt; -#(bnot(n))(-#(bnot(n))(bits)) == bits
  case/Bits bits
  | b0 =&gt; cong(~Bits, ~Bits, ~(-#(bnot(n)))((-#(bnot(n)))(pred)), ~pred, ~b0, ~main(pred))
  | b1 =&gt; cong(~Bits, ~Bits, ~(-#(bnot(n)))((-#(bnot(n)))(pred)), ~pred, ~b1, ~main(pred))
  | be =&gt; refl(~be)
  : -#(bnot(step(n)))(-#(bnot(step(n)))(self)) == self
  * refl(~bits)
</pre></div>
</div>
<p>As usual, it could be simplified with case’d arguments:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>!main*n : !{case bits : Bits} -&gt; -#(bnot(n))(-#(bnot(n))(bits)) == bits
| b0 =&gt; cong(~Bits, ~Bits, ~(-#(bnot(n)))((-#(bnot(n)))(bits.pred)), ~bits.pred, ~b0, ~main(bits.pred))
| b1 =&gt; cong(~Bits, ~Bits, ~(-#(bnot(n)))((-#(bnot(n)))(bits.pred)), ~bits.pred, ~b1, ~main(bits.pred))
| be =&gt; refl(~be)
* refl(~bits)
</pre></div>
</div>
<p>Note that the big difference here, with relation to Agda/Coq proofs, is that, in their cases, since recursive functions are defined by structural recursion, inductive proofs are also defined by recursion on the structure. For example, if we wanted to prove this theorem in Agda, we’d just match the bit-string, prove the base case by reflexivity, and prove the recursive case by calling <code class="docutils literal notranslate"><span class="pre">main</span></code> recursively on <code class="docutils literal notranslate"><span class="pre">pred</span></code>.</p>
<p>In Formality, it <strong>looks</strong> like the proof is the same, but there is a subtle, yet important, difference: under the hoods, we’re not actually recursing on the <code class="docutils literal notranslate"><span class="pre">Bits</span></code> structure. Instead, we’re folding over <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">:</span> <span class="pre">Ind</span></code>, a datatype capturing the inductive hypothesis on natural numbers. As such, in order to prove that <code class="docutils literal notranslate"><span class="pre">bnot(n,</span> <span class="pre">bnot(n,</span> <span class="pre">bits))</span> <span class="pre">==</span> <span class="pre">bits</span></code> hold for any <code class="docutils literal notranslate"><span class="pre">n</span></code>, we first must prove that it is true for <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">0</span></code>, i.e., when <code class="docutils literal notranslate"><span class="pre">bits</span></code> has a maximum recursion depth of <code class="docutils literal notranslate"><span class="pre">0</span></code> (i.e., is “out-of-gas”), which is true by reflexivity since the function returns <code class="docutils literal notranslate"><span class="pre">bits</span></code> itself. We then prove that assuming this is true for a maximum recursion depth of <code class="docutils literal notranslate"><span class="pre">n</span></code>, then it is also true for <code class="docutils literal notranslate"><span class="pre">bits(step(n))</span></code>. This is the <code class="docutils literal notranslate"><span class="pre">step</span></code> case, which coincides with Agda’s proof.</p>
<p>Proving that kind of inductive theorem on Formality is a little more verbose than in Agda, since you have to wrap the whole proof inside <code class="docutils literal notranslate"><span class="pre">Ind</span></code>, and always tell the compiler what to do when the function “runs out of gas”. In exchange, since termination is guaranteed by EAL, there is no “structural recursion” checker, so you’re allowed to be more flexible in your recursive definitions.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../runtime/Formality-Net.html" class="btn btn-neutral float-right" title="1. Formality Net" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="6.7.Boxes.html" class="btn btn-neutral float-left" title="6. Box System" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Ethereum Foundation and Sunshine Cybernetics

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>