

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Formality-Core Tutorial &mdash; Formality 0.3.91 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #444053" >
          

          
            <a href="../index.html">
          

          
            
            <img src="../_static/formality-logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                3.91
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Language</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/1.Motivation.html">1. Motivation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/1.Motivation.html#optimal-substitutions">1.1. Optimal substitutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/1.Motivation.html#a-perfect-execution-model">1.2. A “perfect” execution model</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/1.Motivation.html#a-powerful-type-theory">1.3. A powerful type-theory</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/2.Installation.html">2. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/3.Hello,-world!.html">3. Hello, World!</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/3.Hello,-world!.html#running-a-program">3.1. Running a program</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/3.Hello,-world!.html#imports">3.2. Imports</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/3.Hello,-world!.html#global-imports">3.3. Global imports</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/3.Hello,-world!.html#evaluating">3.4. Evaluating</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/3.Hello,-world!.html#type-checking">3.5. Type-checking</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/4.Basics.html">4. Basics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/4.Basics.html#let">4.1. Let</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/4.Basics.html#words">4.2. Words</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/4.Basics.html#if">4.3. If</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/4.Basics.html#pairs">4.4. Pairs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/4.Basics.html#functions">4.5. Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/5.Datatypes.html">5. Datatypes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/5.Datatypes.html#simple-datatypes">5.1. Simple datatypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/5.Datatypes.html#container-datatypes">5.2. Container datatypes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/5.Datatypes.html#nested-cases">5.2.1. Nested cases</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/5.Datatypes.html#recursive-datatypes">5.3. Recursive datatypes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../language/5.Datatypes.html#recursive-functions">5.3.1. Recursive functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../language/5.Datatypes.html#polymorphic-datatypes">5.4. Polymorphic datatypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/5.Datatypes.html#indexed-datatypes">5.5. Indexed datatypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/5.Datatypes.html#self-encodings">5.6. Self-Encodings</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/6.7.Boxes.html">6. Box System</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/6.7.Boxes.html#avoid-making-a-copy">6.1. Avoid making a copy.</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/6.7.Boxes.html#use-case-d-arguments">7. Use case’d arguments.</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/6.7.Boxes.html#make-a-manual-copy">7.1. Make a manual copy.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/6.7.Boxes.html#use-boxes">7.2. Use boxes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/6.7.Boxes.html#loops-and-recursion">7.3. Loops and Recursion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../language/8.Theorem-Proving.html">8. Theorem Proving</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../language/8.Theorem-Proving.html#equality">8.1. Equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/8.Theorem-Proving.html#simple-proofs">8.2. Simple proofs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../language/8.Theorem-Proving.html#inductive-proofs">8.3. Inductive proofs</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Runtime</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../runtime/Formality-Net.html">1. Formality Net</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../runtime/Formality-Net.html#rewrite-rules">1.1. Rewrite rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#erasure">1.1.1. Erasure</a></li>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#substitution">1.1.2. Substitution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#duplication">1.1.3. Duplication</a></li>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#if-then-else">1.1.4. If-Then-Else</a></li>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#num-operation">1.1.5. Num-Operation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../runtime/Formality-Net.html#compiling-fm-core-to-fm-net">1.2. Compiling FM-Core to FM-Net</a></li>
<li class="toctree-l2"><a class="reference internal" href="../runtime/Formality-Net.html#implementation">1.3. Implementation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#rewrites">1.3.1. Rewrites</a></li>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#strict-evaluation">1.3.2. Strict evaluation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../runtime/Formality-Net.html#lazy-evaluation">1.3.3. Lazy evaluation</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Formality</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Formality-Core Tutorial</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/tutorial/FMC-Tutorial.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="formality-core-tutorial">
<h1>Formality-Core Tutorial<a class="headerlink" href="#formality-core-tutorial" title="Permalink to this headline">¶</a></h1>
<p>This tutorial aims to teach how to effectively develop Formality-Core code, assuming experience in functional programming languages, in special Haskell. Formality-Core is a minimal language based on elementary affine logic, making it compatible with optimal reductions. It can be seen as the GHC Core to the upcoming Formality language. Its minimalism, the lack of a type system, and its unusual boxed duplication system make it a very bare-bones language that isn’t easy to work with directly, demanding that the programmer learns some delicate techniques to be productive.</p>
<div class="section" id="core-features">
<h2>1. Core features<a class="headerlink" href="#core-features" title="Permalink to this headline">¶</a></h2>
<p>Before proceeding, you should have Formality <a class="reference external" href="../language/Installation">installed</a>, and be familiar with its core features and syntax. If you’re not yet, please read the entire <a class="reference internal" href="../Why.html"><span class="doc">Language</span></a> section of this documentation.</p>
</div>
<div class="section" id="simple-datatypes">
<h2>2. Simple datatypes<a class="headerlink" href="#simple-datatypes" title="Permalink to this headline">¶</a></h2>
<p>Algebraic Datatypes (ADTs) are the building bricks of functional programming languages like Haskell, where all programs are just functions operating on ADTs. Programming in Formality isn’t fundamentally different. As such, the best way to learn it is by learning how to translate Haskell code.</p>
<p>Let’s start with a simple type: booleans. In Haskell, they can be defined with the following declaration:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE NoImplicitPrelude #-}</span>

<span class="kr">data</span> <span class="kt">Bool</span>
  <span class="ow">=</span> <span class="kt">True</span>
  <span class="o">|</span> <span class="kt">False</span>
</pre></div>
</div>
<p>This puts 2 constructors, <code class="docutils literal notranslate"><span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">False</span></code> in scope. In Formality, there is no <code class="docutils literal notranslate"><span class="pre">data</span></code> syntax, instead we use <code class="docutils literal notranslate"><span class="pre">T</span></code>:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">T</span> <span class="nx">Bool</span>
<span class="o">|</span> <span class="nx">True</span>
<span class="o">|</span> <span class="nx">False</span>
</pre></div>
</div>
<p>Let’s attempt to translate a simple function, <code class="docutils literal notranslate"><span class="pre">not</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">not</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">not</span> <span class="kt">True</span>  <span class="ow">=</span> <span class="kt">False</span>
<span class="nf">not</span> <span class="kt">False</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>The first thing we must do is get rid of Haskell’s equational notation (which Formality-Core doesn’t have) in favor of lambdas and case-ofs, like this:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">not</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">not</span> <span class="ow">=</span> <span class="nf">\</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">a</span> <span class="kr">of</span> <span class="p">{</span>
  <span class="kt">True</span>  <span class="ow">-&gt;</span> <span class="kt">False</span><span class="p">;</span>
  <span class="kt">False</span> <span class="ow">-&gt;</span> <span class="kt">True</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For the sake of clarity, it is also recommended that each case is given a name with a <code class="docutils literal notranslate"><span class="pre">let</span></code>, as follows:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">not</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">not</span> <span class="ow">=</span> <span class="nf">\</span> <span class="n">a</span> <span class="ow">-&gt;</span>
  <span class="kr">let</span> <span class="n">case_True</span>  <span class="ow">=</span> <span class="kt">False</span> <span class="kr">in</span>
  <span class="kr">let</span> <span class="n">case_False</span> <span class="ow">=</span> <span class="kt">True</span> <span class="kr">in</span>
  <span class="p">(</span><span class="kr">case</span> <span class="n">a</span> <span class="kr">of</span> <span class="p">{</span> <span class="kt">True</span> <span class="ow">-&gt;</span> <span class="n">case_True</span><span class="p">;</span> <span class="kt">False</span> <span class="ow">-&gt;</span> <span class="n">case_False</span> <span class="p">})</span>
</pre></div>
</div>
<p>Once a Haskell program is in this shape, translating it to Formality is straigthforward: we just have to adjust the syntax.</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">not</span> <span class="o">:</span> <span class="p">{</span><span class="nx">x</span> <span class="o">:</span> <span class="nx">Bool</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nx">Bool</span>
  <span class="k">case</span><span class="o">&lt;</span><span class="nx">Bool</span><span class="o">&gt;</span> <span class="nx">x</span>
  <span class="o">|</span> <span class="nx">True</span>  <span class="p">=&gt;</span> <span class="nx">False</span>
  <span class="o">|</span> <span class="nx">False</span> <span class="p">=&gt;</span> <span class="nx">True</span>
  <span class="o">:</span> <span class="nx">Bool</span>
</pre></div>
</div>
<p>Run the program below with <code class="docutils literal notranslate"><span class="pre">fm</span> <span class="pre">&lt;file_name&gt;.main</span></code>.</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">T</span> <span class="nx">Bool</span>
<span class="o">|</span> <span class="nx">True</span>
<span class="o">|</span> <span class="nx">False</span>

<span class="nx">not</span> <span class="o">:</span> <span class="p">{</span><span class="nx">x</span> <span class="o">:</span> <span class="nx">Bool</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nx">Bool</span>
  <span class="k">case</span><span class="o">&lt;</span><span class="nx">Bool</span><span class="o">&gt;</span> <span class="nx">x</span>
  <span class="o">|</span> <span class="nx">True</span>  <span class="p">=&gt;</span> <span class="nx">False</span>
  <span class="o">|</span> <span class="nx">False</span> <span class="p">=&gt;</span> <span class="nx">True</span>
  <span class="o">:</span> <span class="nx">Bool</span>

<span class="nx">main</span> <span class="o">:</span> <span class="nx">Bool</span>
  <span class="nx">not</span><span class="p">(</span><span class="nx">False</span><span class="p">)</span>
</pre></div>
</div>
<p>As an exercise, implement <code class="docutils literal notranslate"><span class="pre">bool_to_nat</span></code>, which returns <code class="docutils literal notranslate"><span class="pre">1</span></code> or <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</div>
<div class="section" id="efficient-branching">
<h2>3. Efficient branching<a class="headerlink" href="#efficient-branching" title="Permalink to this headline">¶</a></h2>
<p>Let’s now translate the following <code class="docutils literal notranslate"><span class="pre">and</span></code> function:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Exhaustive patterns for the sake of demonstration</span>
<span class="nf">and</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">and</span> <span class="kt">True</span>  <span class="kt">True</span>  <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">and</span> <span class="kt">False</span> <span class="kt">True</span>  <span class="ow">=</span> <span class="kt">False</span>
<span class="nf">and</span> <span class="kt">True</span>  <span class="kt">False</span> <span class="ow">=</span> <span class="kt">False</span>
<span class="nf">and</span> <span class="kt">False</span> <span class="kt">False</span> <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Converting the syntax to Formality:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">and</span> <span class="o">:</span> <span class="p">{</span><span class="nx">a</span> <span class="o">:</span> <span class="nx">Bool</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="nx">Bool</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nx">Bool</span>
  <span class="k">case</span><span class="o">&lt;</span><span class="nx">Bool</span><span class="o">&gt;</span> <span class="nx">a</span>
  <span class="o">|</span> <span class="nx">True</span>  <span class="p">=&gt;</span> <span class="nx">b</span>
  <span class="o">|</span> <span class="nx">False</span> <span class="p">=&gt;</span> <span class="nx">False</span>
  <span class="o">:</span> <span class="nx">Bool</span>

<span class="nx">and2</span> <span class="o">:</span> <span class="p">{</span><span class="o">|</span><span class="nx">a</span> <span class="o">:</span> <span class="nx">Bool</span><span class="p">,</span> <span class="o">|</span><span class="nx">b</span><span class="o">:</span> <span class="nx">Bool</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="nx">Bool</span>
<span class="o">|</span> <span class="nx">True</span>  <span class="o">|</span> <span class="nx">True</span>  <span class="o">=</span> <span class="nx">True</span>
        <span class="o">|</span> <span class="nx">False</span> <span class="o">=</span> <span class="nx">False</span>
<span class="o">|</span> <span class="nx">False</span> <span class="o">|</span> <span class="nx">True</span>  <span class="o">=</span> <span class="nx">False</span>
        <span class="o">|</span> <span class="nx">False</span> <span class="o">=</span> <span class="nx">False</span>
</pre></div>
</div>
<p>Here is another example:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">swap</span>    <span class="o">=</span> <span class="mi">0</span> <span class="c1">// Change to 1 to swap</span>
<span class="kd">let</span> <span class="nx">big_arr</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span> <span class="mi">3</span><span class="p">,[</span> <span class="mi">4</span><span class="p">,[</span> <span class="mi">5</span><span class="p">,[</span> <span class="mi">6</span><span class="p">,[</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]]]]]]]</span>
<span class="kd">let</span> <span class="nx">big_str</span> <span class="o">=</span> <span class="s2">&quot;I&#39;m a big string with a lot of stuff!&quot;</span>
<span class="p">(</span><span class="k">if</span> <span class="nx">swap</span>
  <span class="nx">then</span><span class="o">:</span> <span class="p">{</span><span class="nx">big_arr</span> <span class="nx">big_str</span><span class="p">}</span> <span class="p">[</span><span class="nx">big_str</span><span class="p">,</span> <span class="nx">big_arr</span><span class="p">]</span>
  <span class="k">else</span><span class="o">:</span> <span class="p">{</span><span class="nx">big_arr</span> <span class="nx">big_str</span><span class="p">}</span> <span class="p">[</span><span class="nx">big_arr</span><span class="p">,</span> <span class="nx">big_str</span><span class="p">]</span>
  <span class="nx">big_arr</span> <span class="nx">big_str</span><span class="p">)</span>
</pre></div>
</div>
<p>This snippet creates an array and a string and then makes a pair of both with either the string first or the array first, depending on the value of <code class="docutils literal notranslate"><span class="pre">swap</span></code>. Despite using <code class="docutils literal notranslate"><span class="pre">big_str</span></code> and <code class="docutils literal notranslate"><span class="pre">big_arr</span></code> in both branches, those values were never copied thanks to the technique above.</p>
<p>Run the program below with <code class="docutils literal notranslate"><span class="pre">fmc</span> <span class="pre">main</span></code>.</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">def</span> <span class="nx">True</span><span class="o">:</span> <span class="p">{</span><span class="nx">True</span> <span class="nx">False</span><span class="p">}</span>
  <span class="nx">True</span>

<span class="nx">def</span> <span class="nx">False</span><span class="o">:</span> <span class="p">{</span><span class="nx">True</span> <span class="nx">False</span><span class="p">}</span>
  <span class="nx">False</span>

<span class="nx">def</span> <span class="nx">and</span><span class="o">:</span> <span class="p">{</span><span class="nx">a</span> <span class="nx">b</span><span class="p">}</span>
  <span class="kd">let</span> <span class="nx">case_a_True</span> <span class="o">=</span> <span class="p">{</span><span class="nx">b</span><span class="p">}</span>
    <span class="kd">let</span> <span class="nx">case_b_True</span>  <span class="o">=</span> <span class="nx">True</span>
    <span class="kd">let</span> <span class="nx">case_b_False</span> <span class="o">=</span> <span class="nx">False</span>
    <span class="p">(</span><span class="nx">b</span> <span class="nx">case_b_True</span> <span class="nx">case_b_False</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nx">case_a_False</span> <span class="o">=</span> <span class="p">{</span><span class="nx">b</span><span class="p">}</span>
    <span class="kd">let</span> <span class="nx">case_b_True</span>  <span class="o">=</span> <span class="nx">False</span>
    <span class="kd">let</span> <span class="nx">case_b_False</span> <span class="o">=</span> <span class="nx">False</span>
    <span class="p">(</span><span class="nx">b</span> <span class="nx">case_b_True</span> <span class="nx">case_b_False</span><span class="p">)</span>
  <span class="p">(</span><span class="nx">a</span> <span class="nx">case_a_True</span> <span class="nx">case_a_False</span> <span class="nx">b</span><span class="p">)</span>

<span class="nx">def</span> <span class="nx">main</span><span class="o">:</span> 
  <span class="kd">let</span> <span class="nx">bool</span> <span class="o">=</span> <span class="p">(</span><span class="nx">and</span> <span class="nx">True</span> <span class="nx">False</span><span class="p">)</span>

  <span class="c1">// Prints the value of Bool</span>
  <span class="kd">let</span> <span class="nx">case_True</span>  <span class="o">=</span> <span class="s2">&quot;I&#39;m true!&quot;</span>
  <span class="kd">let</span> <span class="nx">case_False</span> <span class="o">=</span> <span class="s2">&quot;I&#39;m false!&quot;</span>
  <span class="p">(</span><span class="nx">bool</span> <span class="nx">case_True</span> <span class="nx">case_False</span><span class="p">)</span>
</pre></div>
</div>
<p>As an exercise, implement <code class="docutils literal notranslate"><span class="pre">or</span></code>.</p>
</div>
<div class="section" id="datatypes-with-fields">
<h2>4. Datatypes with fields<a class="headerlink" href="#datatypes-with-fields" title="Permalink to this headline">¶</a></h2>
<p>In Haskell, pairs can be defined as:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE NoImplicitPrelude #-}</span>

<span class="kr">data</span> <span class="kt">Pair</span> <span class="n">a</span> <span class="n">b</span>
  <span class="ow">=</span> <span class="kt">NewPair</span> <span class="n">a</span> <span class="n">b</span>
</pre></div>
</div>
<p>This puts 1 constructor, <code class="docutils literal notranslate"><span class="pre">NewPair</span></code>, in scope. This is the corresponding Formality-Core definitions:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">NewPair</span> <span class="p">{</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">}</span> <span class="p">{</span><span class="nx">NewPair</span><span class="p">}</span>
  <span class="nx">NewPair</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice that those are mostly similar to <code class="docutils literal notranslate"><span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">False</span></code>, except now there are two fields, <code class="docutils literal notranslate"><span class="pre">{a</span> <span class="pre">b}</span></code>, involved. Let’s write the first accessor function in the Formality-ready form:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fst</span> <span class="ow">::</span> <span class="kt">Pair</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">fst</span> <span class="ow">=</span> <span class="nf">\</span> <span class="n">pair</span> <span class="ow">-&gt;</span> 
  <span class="kr">let</span> <span class="n">case_NewPair</span> <span class="ow">=</span> <span class="nf">\</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="kr">in</span>
  <span class="kr">case</span> <span class="n">pair</span> <span class="kr">of</span> <span class="p">{</span> <span class="kt">NewPair</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">case_NewPair</span> <span class="n">a</span> <span class="n">b</span> <span class="p">}</span>
</pre></div>
</div>
<p>Notice that, here, each field of the datatype became a lambda on the <code class="docutils literal notranslate"><span class="pre">case_NewPair</span></code> expression. This is the Formality translation:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">def</span> <span class="nx">fst</span><span class="o">:</span> <span class="p">{</span><span class="nx">pair</span><span class="p">}</span>
  <span class="kd">let</span> <span class="nx">case_NewPair</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span> <span class="nx">b</span><span class="p">}</span> <span class="nx">a</span>
  <span class="p">(</span><span class="nx">pair</span> <span class="nx">case_NewPair</span><span class="p">)</span>
</pre></div>
</div>
<p>Run the program below with <code class="docutils literal notranslate"><span class="pre">fmc</span> <span class="pre">main</span></code>.</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">def</span> <span class="nx">NewPair</span><span class="o">:</span> <span class="p">{</span><span class="nx">a</span> <span class="nx">b</span><span class="p">}</span> <span class="p">{</span><span class="nx">NewPair</span><span class="p">}</span>
  <span class="p">(</span><span class="nx">NewPair</span> <span class="nx">a</span> <span class="nx">b</span><span class="p">)</span>

<span class="nx">def</span> <span class="nx">get_first</span><span class="o">:</span> <span class="p">{</span><span class="nx">pair</span><span class="p">}</span>
  <span class="kd">let</span> <span class="nx">case_NewPair</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span> <span class="nx">b</span><span class="p">}</span> <span class="nx">a</span>
  <span class="p">(</span><span class="nx">pair</span> <span class="nx">case_NewPair</span><span class="p">)</span>

<span class="nx">def</span> <span class="nx">main</span><span class="o">:</span> 
  <span class="kd">let</span> <span class="nx">pair</span> <span class="o">=</span> <span class="p">(</span><span class="nx">NewPair</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>

  <span class="c1">// Prints the first element of `pair`</span>
  <span class="p">(</span><span class="nx">get_first</span> <span class="nx">pair</span><span class="p">)</span>
</pre></div>
</div>
<p>As an exercise, implement <code class="docutils literal notranslate"><span class="pre">pair_swap</span></code>.</p>
</div>
<div class="section" id="non-recursive-datatypes">
<h2>5. Non-recursive datatypes<a class="headerlink" href="#non-recursive-datatypes" title="Permalink to this headline">¶</a></h2>
<p>Here are 2 more Haskell datatypes:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span>
  <span class="ow">=</span> <span class="kt">Nothing</span>
  <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>

<span class="kr">data</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span>
  <span class="ow">=</span> <span class="kt">Left</span> <span class="n">a</span>
  <span class="o">|</span> <span class="kt">Right</span> <span class="n">b</span>
</pre></div>
</div>
<p>This puts 4 constructors, <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, <code class="docutils literal notranslate"><span class="pre">Just</span></code>, <code class="docutils literal notranslate"><span class="pre">Left</span></code>, <code class="docutils literal notranslate"><span class="pre">Right</span></code> in scope. Those are the corresponding Formality-Core definitions:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">def</span> <span class="nx">Nothing</span><span class="o">:</span> <span class="p">{</span><span class="nx">Nothing</span> <span class="nx">Just</span><span class="p">}</span>
  <span class="nx">Nothing</span>

<span class="nx">def</span> <span class="nx">Just</span><span class="o">:</span> <span class="p">{</span><span class="nx">a</span><span class="p">}</span> <span class="p">{</span><span class="nx">Nothing</span> <span class="nx">Just</span><span class="p">}</span>
  <span class="p">(</span><span class="nx">Just</span> <span class="nx">a</span><span class="p">)</span>

<span class="nx">def</span> <span class="nx">Left</span><span class="o">:</span> <span class="p">{</span><span class="nx">a</span><span class="p">}</span> <span class="p">{</span><span class="nx">Left</span> <span class="nx">Right</span><span class="p">}</span>
  <span class="p">(</span><span class="nx">Left</span> <span class="nx">a</span><span class="p">)</span>

<span class="nx">def</span> <span class="nx">Right</span><span class="o">:</span> <span class="p">{</span><span class="nx">b</span><span class="p">}</span> <span class="p">{</span><span class="nx">Left</span> <span class="nx">Right</span><span class="p">}</span>
  <span class="p">(</span><span class="nx">Right</span> <span class="nx">b</span><span class="p">)</span>
</pre></div>
</div>
<p>From this, you should be able to grasp the general pattern:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">def</span> <span class="nx">Ctor_0</span><span class="o">:</span> <span class="p">{</span><span class="nx">ctor_0_field_0</span> <span class="nx">ctor_0_field_1</span> <span class="p">...}</span> <span class="p">{</span><span class="nx">Ctor_0</span> <span class="nx">Ctor_1</span> <span class="p">...}</span>
  <span class="p">(</span><span class="nx">Ctor_0</span> <span class="nx">ctor_0_field_0</span> <span class="nx">ctor_0_field_1</span> <span class="p">...)</span>

<span class="nx">def</span> <span class="nx">Ctor_1</span><span class="o">:</span> <span class="p">{</span><span class="nx">ctor_1_field_0</span> <span class="nx">ctor_1_field_1</span> <span class="p">...}</span> <span class="p">{</span><span class="nx">Ctor_0</span> <span class="nx">Ctor_1</span> <span class="p">...}</span>
  <span class="p">(</span><span class="nx">Ctor_1</span> <span class="nx">ctor_1_field_0</span> <span class="nx">ctor_1_field_1</span> <span class="p">...)</span>

<span class="p">...</span>
</pre></div>
</div>
<p>Let’s now implement a <code class="docutils literal notranslate"><span class="pre">from_just</span> <span class="pre">::</span> <span class="pre">Maybe</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Either</span> <span class="pre">String</span> <span class="pre">a</span></code> function that either extracts the value of a <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, or returns an error:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">from_just</span><span class="p">:</span> <span class="p">{</span><span class="n">error_msg</span> <span class="n">maybe_val</span><span class="p">}</span>
  <span class="n">let</span> <span class="n">case_nothing</span> <span class="o">=</span> <span class="p">(</span><span class="n">Left</span> <span class="n">error_msg</span><span class="p">)</span>
  <span class="n">let</span> <span class="n">case_just</span>    <span class="o">=</span> <span class="p">{</span><span class="n">val</span><span class="p">}</span> <span class="p">(</span><span class="n">Right</span> <span class="n">val</span><span class="p">)</span>
  <span class="p">(</span><span class="n">maybe_val</span> <span class="n">case_nothing</span> <span class="n">case_just</span><span class="p">)</span>
</pre></div>
</div>
<p>By this point, you should be able to understand this. The general pattern for matching is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">case_Ctor_0</span> <span class="o">=</span> <span class="p">{</span><span class="n">ctor_0_field_0</span> <span class="n">ctor_0_field_1</span> <span class="o">...</span><span class="p">}</span> <span class="n">result_on_case_Ctor0</span>
<span class="n">let</span> <span class="n">case_Ctor_1</span> <span class="o">=</span> <span class="p">{</span><span class="n">ctor_1_field_0</span> <span class="n">ctor_1_field_1</span> <span class="o">...</span><span class="p">}</span> <span class="n">result_on_case_Ctor1</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Run the program below with <code class="docutils literal notranslate"><span class="pre">fmc</span> <span class="pre">main</span></code>.</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">def</span> <span class="nx">Nothing</span><span class="o">:</span> <span class="p">{</span><span class="nx">Nothing</span> <span class="nx">Just</span><span class="p">}</span>
  <span class="nx">Nothing</span>

<span class="nx">def</span> <span class="nx">Just</span><span class="o">:</span> <span class="p">{</span><span class="nx">a</span><span class="p">}</span> <span class="p">{</span><span class="nx">Nothing</span> <span class="nx">Just</span><span class="p">}</span>
  <span class="p">(</span><span class="nx">Just</span> <span class="nx">a</span><span class="p">)</span>

<span class="nx">def</span> <span class="nx">Left</span><span class="o">:</span> <span class="p">{</span><span class="nx">a</span><span class="p">}</span> <span class="p">{</span><span class="nx">Left</span> <span class="nx">Right</span><span class="p">}</span>
  <span class="p">(</span><span class="nx">Left</span> <span class="nx">a</span><span class="p">)</span>

<span class="nx">def</span> <span class="nx">Right</span><span class="o">:</span> <span class="p">{</span><span class="nx">b</span><span class="p">}</span> <span class="p">{</span><span class="nx">Left</span> <span class="nx">Right</span><span class="p">}</span>
  <span class="p">(</span><span class="nx">Right</span> <span class="nx">b</span><span class="p">)</span>

<span class="nx">def</span> <span class="nx">from_just</span><span class="o">:</span> <span class="p">{</span><span class="nx">error_msg</span> <span class="nx">maybe_val</span><span class="p">}</span>
  <span class="kd">let</span> <span class="nx">case_nothing</span> <span class="o">=</span> <span class="p">(</span><span class="nx">Left</span> <span class="nx">error_msg</span><span class="p">)</span>
  <span class="kd">let</span> <span class="nx">case_just</span>    <span class="o">=</span> <span class="p">{</span><span class="nx">val</span><span class="p">}</span> <span class="p">(</span><span class="nx">Right</span> <span class="nx">val</span><span class="p">)</span>
  <span class="p">(</span><span class="nx">maybe_val</span> <span class="nx">case_nothing</span> <span class="nx">case_just</span><span class="p">)</span>

<span class="nx">def</span> <span class="nx">main</span><span class="o">:</span>
  <span class="kd">let</span> <span class="nx">maybe_a</span> <span class="o">=</span> <span class="nx">Nothing</span>
  <span class="kd">let</span> <span class="nx">maybe_b</span> <span class="o">=</span> <span class="p">(</span><span class="nx">Just</span> <span class="mi">3</span><span class="p">)</span>
  <span class="p">(</span><span class="nx">from_just</span> <span class="s2">&quot;I&#39;m not a number.&quot;</span> <span class="nx">maybe_a</span><span class="p">)</span>
</pre></div>
</div>
<p>As an exercise, implement <code class="docutils literal notranslate"><span class="pre">to_maybe</span> <span class="pre">::</span> <span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">b</span></code>.</p>
</div>
<div class="section" id="unboxed-copying">
<h2>6. Unboxed copying<a class="headerlink" href="#unboxed-copying" title="Permalink to this headline">¶</a></h2>
<p>Remember that Formality-Core functions can only use its bound variable once. Because of that, it is hard to make duplicates of a value. For example, this isn’t possible:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// square : Nat -&gt; Nat</span>
<span class="nx">def</span> <span class="nx">square</span><span class="o">:</span> <span class="p">{</span><span class="nx">n</span><span class="p">}</span>
  <span class="o">|</span><span class="nx">n</span> <span class="o">*</span> <span class="nx">n</span><span class="o">|</span>
</pre></div>
</div>
<p>Here, we learned how to avoid this problem when the copy is needed in a different branch, but what if we really need the value twice, like on the case above? Fortunately, as explained on the <a class="reference external" href="https://github.com/moonad/Formality/wiki/Dups-and-Boxes">wiki</a>, Formality-Core includes an explicit duplication system that allows us to write this:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>// square : !Nat -&gt; !Nat
def square: {n}
  dup n = n
  # |n * n|
</pre></div>
</div>
<p>But this kind of definition has an important limitation: it can only affect a number in a layer below it! In general, a term on layer <code class="docutils literal notranslate"><span class="pre">N</span></code> can’t read any information from a term on layer <code class="docutils literal notranslate"><span class="pre">N+1</span></code>. Because of that, you <strong>often want all data of your program to live in a single layer and avoid boxes as much as possible</strong>. But then, how do we copy values? On the <code class="docutils literal notranslate"><span class="pre">square</span></code> case, what you want to do is to use the <code class="docutils literal notranslate"><span class="pre">cpy</span></code> primitive, which allows you to copy a number as many times as you want:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="c1">// square : Nat -&gt; Nat</span>
<span class="nx">def</span> <span class="nx">square</span><span class="o">:</span> <span class="p">{</span><span class="nx">n</span><span class="p">}</span>
  <span class="nx">cpy</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">n</span>
  <span class="o">|</span><span class="nx">n</span> <span class="o">*</span> <span class="nx">n</span><span class="o">|</span>
</pre></div>
</div>
<p>For user-defined algebraic datatype, you must write an explicit <code class="docutils literal notranslate"><span class="pre">copy</span></code> function, which performs a pattern-match and explicitly returns copies of the same value. For example:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">def</span> <span class="nx">copy_bool</span><span class="o">:</span> <span class="p">{</span><span class="nx">b</span><span class="p">}</span>
  <span class="kd">let</span> <span class="nx">case_true</span>  <span class="o">=</span> <span class="p">[</span><span class="nx">True</span><span class="p">,</span> <span class="nx">True</span><span class="p">]</span>
  <span class="kd">let</span> <span class="nx">case_false</span> <span class="o">=</span> <span class="p">[</span><span class="nx">False</span><span class="p">,</span> <span class="nx">False</span><span class="p">]</span>
  <span class="p">(</span><span class="nx">b</span> <span class="nx">case_true</span> <span class="nx">case_false</span><span class="p">)</span>

<span class="nx">def</span> <span class="nx">main</span><span class="o">:</span>
  <span class="kd">let</span> <span class="nx">bool</span> <span class="o">=</span> <span class="nx">True</span>
  <span class="nx">get</span> <span class="p">[</span><span class="nx">bool_cpy_0</span><span class="p">,</span> <span class="nx">bool_cpy_1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">copy_bool</span> <span class="nx">bool</span><span class="p">)</span>
  <span class="p">...</span>
</pre></div>
</div>
<p>This is an annoying complication that could and should be automated on the Formality language. When dealing with Formality-Core, writing explicit copy functions is one of the programmer’s job. As an exercise, write a <code class="docutils literal notranslate"><span class="pre">copy_bool_pair</span></code> function that copies a pair of bools (i.e., <code class="docutils literal notranslate"><span class="pre">(copy_bool_pair</span> <span class="pre">[True,</span> <span class="pre">False])</span> <span class="pre">==</span> <span class="pre">[[True,False],</span> <span class="pre">[True,False]]</span></code>).</p>
</div>
<div class="section" id="recursive-datatypes">
<h2>7. Recursive datatypes<a class="headerlink" href="#recursive-datatypes" title="Permalink to this headline">¶</a></h2>
<p>In Haskell, natural numbers and linked lists can be defined as:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="cm">{-# LANGUAGE NoImplicitPrelude #-}</span>

<span class="kr">data</span> <span class="kt">Nat</span>
  <span class="ow">=</span> <span class="kt">Succ</span> <span class="kt">Nat</span>
  <span class="o">|</span> <span class="kt">Zero</span>

<span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span>
  <span class="ow">=</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="p">(</span><span class="kt">List</span> <span class="n">a</span><span class="p">)</span>
  <span class="o">|</span> <span class="kt">Nil</span>
</pre></div>
</div>
<p>This puts 4 constructors, <code class="docutils literal notranslate"><span class="pre">Succ</span></code>, <code class="docutils literal notranslate"><span class="pre">Zero</span></code>, <code class="docutils literal notranslate"><span class="pre">Cons</span></code>, <code class="docutils literal notranslate"><span class="pre">Nil</span></code> in scope. Those are the corresponding Formality-Core definitions:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">def</span> <span class="nx">Succ</span><span class="o">:</span> <span class="p">{</span><span class="nx">n</span><span class="p">}</span> <span class="p">{</span><span class="nx">Succ</span> <span class="nx">Zero</span><span class="p">}</span>
  <span class="p">(</span><span class="nx">Succ</span> <span class="nx">n</span><span class="p">)</span>

<span class="nx">def</span> <span class="nx">Zero</span><span class="o">:</span> <span class="p">{</span><span class="nx">Succ</span> <span class="nx">Zero</span><span class="p">}</span>
  <span class="nx">Zero</span>

<span class="nx">def</span> <span class="nx">Cons</span><span class="o">:</span> <span class="p">{</span><span class="nx">x</span> <span class="nx">xs</span><span class="p">}</span> <span class="p">{</span><span class="nx">Cons</span> <span class="nx">Nil</span><span class="p">}</span>
  <span class="p">(</span><span class="nx">Cons</span> <span class="nx">x</span> <span class="nx">xs</span><span class="p">)</span>

<span class="nx">def</span> <span class="nx">Nil</span><span class="o">:</span> <span class="p">{</span><span class="nx">Cons</span> <span class="nx">Nil</span><span class="p">}</span>
  <span class="nx">Nil</span>
</pre></div>
</div>
<p>There is no surprise here: the definitions are identical to non-recursive datatypes. What changes, though, is that we can’t use those datatypes as expected. This, for example, won’t work:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="nx">def</span> <span class="nx">length</span><span class="o">:</span> <span class="p">{</span><span class="nx">list</span><span class="p">}</span>
  <span class="kd">let</span> <span class="nx">case_cons</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span> <span class="nx">xs</span><span class="p">}</span> <span class="p">(</span><span class="nx">Succ</span> <span class="p">(</span><span class="nx">length</span> <span class="nx">xs</span><span class="p">))</span>
  <span class="kd">let</span> <span class="nx">case_nil</span>  <span class="o">=</span> <span class="nx">Nil</span>
  <span class="p">(</span><span class="nx">list</span> <span class="nx">case_cons</span> <span class="nx">case_nil</span><span class="p">)</span>
</pre></div>
</div>
<p>The problem is that, being a terminating language, recursion isn’t allowed. Recursive datatypes without recursive functions are of limited use. What now?</p>
<p>That’s when boxes become useful. Remember that I told you to avoid using boxes to copy data? That’s because the real use of boxes is to capture loops, folds, and recursion through the so-called “Church-Encodings”. This is best explained through examples. To recursive over a list of length up to 4, this is how you do it:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>def Cons: {x xs} {Cons Nil}
  (Cons x xs)

def Nil: {Cons Nil}
  Nil

def rec4: {call stop}
  dup call = call
  dup stop = stop
  # (call (call (call (call stop))))

def length:
  let call = {rec list}
    let case_cons = {x xs} |1 + (rec xs)|
    let case_nil  = 0
    (list case_cons case_nil)
  let stop = 0
  dup length = (rec4 #call #stop)
  # {list}
    (length list)

def main:
  dup length = length
  # let list = (Cons 7 (Cons 7 Nil))
    [&quot;Length of the list is:&quot;, (length list)]
</pre></div>
</div>
<p>Let’s take a moment to understand what is going on here because this is very important and unusual. First, we create <code class="docutils literal notranslate"><span class="pre">rec4</span></code>, which is the “Church-Encoded” natural number 4, which allows us to execute a recursive function up to 4 calls. Then, we implement <code class="docutils literal notranslate"><span class="pre">length</span></code> using it. There, we define <code class="docutils literal notranslate"><span class="pre">call</span></code>, which is exactly what the usual Haskell <code class="docutils literal notranslate"><span class="pre">length</span></code> function would look like, except that it receives an extra argument, <code class="docutils literal notranslate"><span class="pre">rec</span></code>, to refer to itself. Then, we define <code class="docutils literal notranslate"><span class="pre">stop</span></code>, which is the “default” value in the case the recursion hits its call limit (here, <code class="docutils literal notranslate"><span class="pre">4</span></code>). Then we create the <code class="docutils literal notranslate"><span class="pre">length</span></code> function by applying <code class="docutils literal notranslate"><span class="pre">rec4</span></code> to <code class="docutils literal notranslate"><span class="pre">#call</span></code> and <code class="docutils literal notranslate"><span class="pre">#stop</span></code>. That function will only work up to 4 calls. Since we used <code class="docutils literal notranslate"><span class="pre">dup</span></code>s on <code class="docutils literal notranslate"><span class="pre">layer</span> <span class="pre">0</span></code>, this <code class="docutils literal notranslate"><span class="pre">length</span></code> function will only be available on <code class="docutils literal notranslate"><span class="pre">layer</span> <span class="pre">1</span></code>. That’s why there is a <code class="docutils literal notranslate"><span class="pre">#</span></code> before <code class="docutils literal notranslate"><span class="pre">{list}</span></code>: our entire function is written on layer 1. On this case, we just receive a list and apply <code class="docutils literal notranslate"><span class="pre">length</span></code> to it.</p>
<p>Crazy, right? This is, by far, the most confusing aspect of Formality, so, don’t get afraid if you don’t get it at first. In general, though, you can expect Formality-Core programs to follow roughly the form of the <code class="docutils literal notranslate"><span class="pre">length</span></code> function. First, we “configure” the recursive calls and their “call limits” on layer 0, and then we use them on layer 1. From my experience, under normal circumstances, Formality-Core programs should use no more than two layers. Take a look at <a class="reference external" href="https://github.com/moonad/Formality/blob/master/stdlib/kaelin.fmc"><code class="docutils literal notranslate"><span class="pre">Kaelin</span></code></a>, a small game written in Formality-Core: recursive functions like <code class="docutils literal notranslate"><span class="pre">write</span></code>, <code class="docutils literal notranslate"><span class="pre">update</span></code>, <code class="docutils literal notranslate"><span class="pre">vec2_range</span></code> are “configured” on layer 0, while the game logic and its data live on layer 1. (Note: actually, right now, it is on layer 2, but disregard as this will be changed soon.)</p>
<p>Note: since <code class="docutils literal notranslate"><span class="pre">recN</span></code> is so common, in order to avoid writing it for each <code class="docutils literal notranslate"><span class="pre">n</span></code>, there is quick syntax-sugar to generate it. First, define <code class="docutils literal notranslate"><span class="pre">rec</span></code> as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">rec</span><span class="p">:</span> <span class="p">{</span><span class="n">n</span> <span class="n">call</span> <span class="n">stop</span><span class="p">}</span>
  <span class="n">dup</span> <span class="n">callN</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="n">call</span><span class="p">)</span>
  <span class="n">dup</span> <span class="n">stop</span>  <span class="o">=</span> <span class="n">stop</span>
  <span class="c1"># (callN stop)</span>
</pre></div>
</div>
<p>Then, you can write <code class="docutils literal notranslate"><span class="pre">(rec</span> <span class="pre">~N)</span></code> for any <code class="docutils literal notranslate"><span class="pre">N</span></code>.</p>
</div>
<div class="section" id="fusing-loops">
<h2>8. Fusing loops<a class="headerlink" href="#fusing-loops" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">~</span></code> syntax generates a ultra-compact Church Nats. For example, <code class="docutils literal notranslate"><span class="pre">~256</span></code> becomes:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>{s}
  (dup s0 = s
  (dup s1 = #{x} (s0 (s0 x))
  (dup s2 = #{x} (s1 (s1 x))
  (dup s3 = #{x} (s2 (s2 x))
  (dup s4 = #{x} (s3 (s3 x))
  (dup s5 = #{x} (s4 (s4 x))
  (dup s6 = #{x} (s5 (s5 x))
  (dup s7 = #{x} (s6 (s6 x))
  (dup s8 = #{x} (s7 (s7 x))
    #{x} (s8 x))))))))))
</pre></div>
</div>
<p>Instead of the full form (with <code class="docutils literal notranslate"><span class="pre">256</span></code> applications of <code class="docutils literal notranslate"><span class="pre">s</span></code>). This compact form is useful for getting asymptotical speed-ups over traditional functional languages. For example, the program below:</p>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span>def True: {True False}
  True

def False: {True False}
  False

def not: {a True False}
  let case_True  = False
  let case_False = True
  (a case_True case_False)

def main: 
  let num      = ~1000000000000
  dup num_nots = (num #not)
  # (num_nots True &quot;num is even&quot; &quot;num is odd&quot;)
</pre></div>
</div>
<p>Applies <code class="docutils literal notranslate"><span class="pre">not</span></code> one trillion times to the boolean <code class="docutils literal notranslate"><span class="pre">True</span></code> and returns instantly if running on interaction nets (<code class="docutils literal notranslate"><span class="pre">fmc</span> <span class="pre">-l</span> <span class="pre">main</span></code>). As an experiment, you can try changing the number to anything else and it will always output whether <code class="docutils literal notranslate"><span class="pre">num</span></code> is even or odd, even a computer shouldn’t be able to perform 1 trillion function calls that quickly. That’s one of the cool aspects of Formality and boils down to its ability to perform fusion (like Haskell’s foldr/build technique) at runtime, merging compositions of <code class="docutils literal notranslate"><span class="pre">not</span></code> and essentially performing a loop of <code class="docutils literal notranslate"><span class="pre">N</span></code> iterations in <code class="docutils literal notranslate"><span class="pre">O(log(N))</span></code> graph-rewrites. I write more about this effect <a class="reference external" href="https://medium.com/&#64;maiavictor/solving-the-mystery-behind-abstract-algorithms-magical-optimizations-144225164b07">on this article</a>, and implement a quick, elegant <code class="docutils literal notranslate"><span class="pre">exp_mod</span></code> <a class="reference external" href="https://gist.github.com/MaiaVictor/e556062185c5863d814980123e03630f">on this Gist</a>.</p>
<hr class="docutils" />
<p>Uff, that’s a lot of information already! What now? Help me <a class="reference external" href="https://gitlab.com/sunshine-cybernetics/docs.moonad.org/issues">improving this guide</a>!</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Ethereum Foundation and Sunshine Cybernetics

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>